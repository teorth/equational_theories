import Mathlib.Algebra.DirectSum.Basic
import Mathlib.GroupTheory.FreeGroup.Basic
import Mathlib.Data.ZMod.Defs
import Mathlib.Data.Countable.Defs
import Mathlib.Data.DFinsupp.Encodable

import equational_theories.Equations.All
import equational_theories.ManuallyProved.Equation1729.ExtensionTheorem

/- Constructs the small magma SM, basic properties of the additional set N, and sets out the axioms these objects need to satisfy -/

namespace Eq1729

/- SM is the abelian group generated by countably many generators E n of order 4 -/

abbrev SM := DirectSum ℕ (fun _ ↦ ZMod 4)

open AddToMagma -- makes SM a magma automatically

instance SM_countable : Countable SM := by
  convert instCountableDFinsupp
  . infer_instance
  infer_instance

abbrev E (n:ℕ) : SM := (DirectSum.of (fun _ ↦ ZMod 4) n) 1

@[simp]
lemma SM_op_eq_add (a b : SM) : a ◇ b = a + b := rfl

/- The squaring map on SM -/
def S (a : SM) := a ◇ a

@[simp]
lemma S_zero : S 0 = 0 := rfl

@[simp]
lemma SM_square_square_eq_zero (a : SM) : S (S a) = 0 := by
  simp only [S, SM_op_eq_add]
-- when we update Mathlib, one can switch to DirectSum.ext_component, or use the new version of DirectSum.ext
  apply DirectSum.ext ℤ
  intro i
  simp only [map_add, map_zero]
  abel_nf
  exact ZModModule.char_nsmul_eq_zero 4 _

@[simp]
lemma SM_square_eq_double (a : SM) : S a = a + a := rfl

lemma SM_obeys_1729 : Equation1729 SM := by
  intro x y
  simp only [SM_op_eq_add]
  abel_nf
-- when we update Mathlib, one can switch to DirectSum.ext_component, or use the new version of DirectSum.ext
  apply DirectSum.ext ℤ
  intro i
  simp only [map_add, map_smul, zsmul_eq_mul, Int.cast_ofNat, self_eq_add_left]
  apply zero_mul

def L (a:SM) : SM ≃ SM := {
  toFun := fun x ↦ x + a
  invFun := fun x ↦ x - a
  left_inv := leftInverse_sub_add_left a
  right_inv := by
    intro x
    simp only [sub_add_cancel]
}

def R (a:SM) : SM ≃ SM := L a

/- N is the free group generated by e_a for each a in SM -/

abbrev N := FreeGroup SM

instance N_countable : Countable N := Quotient.countable

abbrev e (a:SM) := FreeGroup.of a

def adjacent (x y : N) := ∃ a, x = (e a) * y ∨ y = (e a) * x

/-- Impose an order on N: y ≤ x if y is a right subword of x  (or equivalently, y is on the unique simple path from
1 to x).  The spelling may not be optimal. -/
instance N_LE : LE N := {
  le := by
    intro x y
    exact ∃ z, x = z * y ∧ x.norm = z.norm + y.norm
}

instance N_order : PartialOrder N  := {
  le := N_LE.le
  lt := by
    intro x y
    exact x ≤ y ∧ x ≠ y
  le_refl := sorry
  le_trans := sorry
  le_antisymm := sorry
  lt_iff_le_not_le := sorry
}

/-- the parent of x is defined to be the unique element adjacent to x whose reduced word is shorter, with the junk convention that the parent of the identity is itself -/
def parent (x : N) : N := FreeGroup.mk x.toWord.dropLast

/- Right-multiplication by an element of SM on N is defined via the group action. -/

def R' (a:SM) : N ≃ N := {
  toFun := fun x ↦ x * (e a)
  invFun := fun x ↦ x * (e a)⁻¹
  left_inv := by
    intro x
    simp only [mul_inv_cancel_right]
  right_inv := by
    intro x
    simp only [inv_mul_cancel_right]
}

lemma R'_axiom_iia (a b : SM) (y:N) (h: a ≠ b): R' a y ≠ R' b y := by
  contrapose! h
  simp only [R', Equiv.coe_fn_mk, mul_right_inj] at h
  exact FreeGroup.of_injective h

lemma R'_axiom_iib (a : SM) (y:N) : R' a y ≠ y := by
  by_contra! h
  simp only [R', Equiv.coe_fn_mk, mul_right_eq_self, FreeGroup.of_ne_one] at h

/- Now we rewrite the axioms using a single transformation L₀' instead of many transformations L' -/

/- Not sure if this is the best spelling for this axiom -/
def axiom_i' (L₀' : N → N) : Prop := L₀' ∘ L₀' = (R' 0).symm

lemma L₀'_R'0_L₀'_eq_id {L₀' : N → N} (h: axiom_i' L₀') : L₀' ∘ R' 0 ∘ L₀' = id := by
  unfold axiom_i' at h
  calc
    _ = L₀' ∘ R' 0 ∘ L₀' ∘ ((L₀' ∘ L₀') ∘ R' 0) := by aesop
    _ = (L₀' ∘ (R' 0 ∘ (L₀' ∘ L₀')) ∘ L₀') ∘ R' 0 := rfl
    _ = _ := by simp only [h, Equiv.self_comp_symm, CompTriple.comp_eq, Equiv.symm_comp_self]

def L' {L₀' : N → N} (h: axiom_i' L₀') (a:SM) : N ≃ N := {
  toFun := (R' a).symm ∘ L₀' ∘  R' (S a)
  invFun := (R' (S a)).symm ∘ L₀' ∘ (R' 0) ∘  (R' a)
  left_inv := by
    rw [Function.leftInverse_iff_comp]
    calc
      _ = (R' (S a)).symm ∘ L₀' ∘ R' 0 ∘ (R' a ∘ (R' a).symm) ∘ L₀' ∘ R' (S a) := rfl
      _ = (R' (S a)).symm ∘ (L₀' ∘ R' 0 ∘ L₀') ∘ R' (S a) := by aesop
      _ = _ := by simp only [L₀'_R'0_L₀'_eq_id h, CompTriple.comp_eq, Equiv.symm_comp_self]
  right_inv := by
    unfold axiom_i' at h
    rw [Function.rightInverse_iff_comp]
    calc
      _ = (R' a).symm ∘ ((L₀' ∘ (R' (S a) ∘ (R' (S a)).symm) ∘ L₀') ∘ R' 0) ∘ R' a := rfl
      _ = _ := by simp only [Equiv.self_comp_symm, CompTriple.comp_eq, h, Equiv.symm_comp_self]
}

lemma L'_0_eq_L₀' {L₀' : N → N} (h: axiom_i' L₀') : L' h 0 = L₀' := by
  unfold L'
  unfold axiom_i' at h
  simp only [← h, SM_square_eq_double, add_zero, Equiv.coe_fn_mk]
  rw [Function.comp_assoc, <- Function.comp_assoc _ _ (R' 0), h]
  simp only [Equiv.symm_comp_self, CompTriple.comp_eq]

abbrev M := SM ⊕ N

variable (f g h : ℕ → ℕ)

example : ℕ := f $ g $ h 0

abbrev axiom_iii' (S': N → SM) (L₀' : N → N)  := ∀ (a : SM) (x y : N), R' a x = y → ((R' (S' y)).symm $ L₀' $ R' (S (S' y)) $ (R' (a - S' x)).symm $ L₀' $ R' (S (a - S' x)) y) = x

abbrev axiom_iv' (S': N → SM) (L₀' : N → N) := ∀ x : N, ((R' (S' x)).symm $ L₀' $ R' (S (S' x)) $ (R' (S' x)).symm $ L₀' $ R' (S (S' x)) $ x) = x

abbrev axiom_v (S': N → SM) (op: N → N → M) := ∀ x : N, op x x = Sum.inl (S' x)

abbrev axiom_vi' (S': N → SM) (op: N → N → M) := ∀ (y : N) (a : SM), op (R' a y) y = Sum.inl (a - S' y)

abbrev axiom_vii' (S': N → SM) (L₀' : N → N) (op: N → N → M) := ∀ x y : N, x ≠ y → (∀ a : SM, x ≠ R' a y) → ∃ z : N, op x y = Sum.inr z ∧ op z x = Sum.inr ((R' (S (S' x))).symm $ L₀' $ R' 0 $ R' (S' x) $ y)

lemma reduce_to_new_axioms {S': N → SM} {L₀' : N → N} {op: N → N → M} (hbij: Function.Bijective L₀') (h_i': axiom_i' L₀') (h_iii': axiom_iii' S' L₀') (h_iv': axiom_iv' S' L₀') (h_v: axiom_v S' op) (h_vi': axiom_vi' S' op) (h_vii': axiom_vii' S' L₀' op) : ∃ (G: Type) (_: Magma G), Equation1729 G ∧ ¬ Equation817 G := by
  suffices : ExtOpsWithProps SM N
  . exact ⟨ M, extMagmaInst this, ExtMagma_sat_eq1729 this, ExtMagma_unsat_eq817 this ⟩
  exact
   {
    S := S
    L := fun x ↦ (fun y ↦ x ◇ y)
    R := fun x ↦ (fun y ↦ y ◇ x)
    S' := S'
    L' := (fun a ↦ L' h_i' a)
    R' := (fun a ↦ R' a)
    rest_map := op
    squaring_prop_SM := by intros; rfl
    left_map_SM := by intros; rfl
    right_map_SM := by intros; rfl
    sqN_extends_sqM := by intro _; aesop -- this is a tautology
    L_inv := by
      intro a
      exact {
        inv := fun y ↦ y - a
        inv_left := by
          ext y
          simp only [SM_op_eq_add, Function.comp_apply, add_sub_cancel_left, id_eq]
        inv_right := by
          ext y
          simp only [SM_op_eq_add, Function.comp_apply, add_sub_cancel, id_eq]
        bij := sorry -- redundant given the other data
      }
    L'_inv := by
      intro a
      exact {
        inv := (L' h_i' a).symm
        inv_left := Equiv.symm_comp_self _
        inv_right := Equiv.self_comp_symm _
        bij := sorry -- redundant given the other data
      }
    R_inv := by
      intro a
      exact {
        inv := fun y ↦ y - a
        inv_left := by
          ext y
          simp only [SM_op_eq_add, Function.comp_apply, add_sub_cancel_right, id_eq]
        inv_right := by
          ext y
          simp only [SM_op_eq_add, Function.comp_apply, sub_add_cancel, id_eq]
        bij := sorry -- redundant given the other data
      }
    R'_inv := by
      intro a
      exact {
        inv := (R' a).symm
        inv_left := Equiv.symm_comp_self _
        inv_right := Equiv.self_comp_symm _
        bij := sorry -- redundant given the other data
      }
    SM_sat_1729 := SM_obeys_1729
    axiom_1 := by
      intro a
      simp only [L', SM_square_square_eq_zero, Equiv.coe_fn_mk]
      calc
        _ = (R' (S a)).symm ∘ (L₀' ∘ (R' 0) ∘ ((R' a) ∘ (R' a).symm) ∘ L₀') ∘ (R' (S a))  := rfl
        _ = _ := by simp [L₀'_R'0_L₀'_eq_id h_i']
    axiom_21 := by
      intro a b y h
      simp only [ne_eq, R'_axiom_iia a b y h, not_false_eq_true]
    axiom_22 := by
      intro a x
      simp only [ne_eq, R'_axiom_iib a x, not_false_eq_true]
    axiom_3 := by
      simp only [L', Equiv.coe_fn_mk, Function.comp_apply]
      intro x y a h
      rw [h_iii' a x y h]
    axiom_4 := sorry
    axiom_5 := sorry
    axiom_6 := sorry
   }

end Eq1729
