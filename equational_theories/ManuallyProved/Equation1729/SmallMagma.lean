import Mathlib.Algebra.DirectSum.Basic
import Mathlib.GroupTheory.FreeGroup.Basic
import Mathlib.Data.ZMod.Defs
import Mathlib.Data.Countable.Defs
import Mathlib.Data.DFinsupp.Encodable
import Mathlib.Algebra.Module.LinearMap.Defs
import Mathlib.RepresentationTheory.Basic

import equational_theories.ForMathlib.GroupTheory.FreeGroup.ReducedWords
import equational_theories.Equations.All
import equational_theories.ManuallyProved.Equation1729.ExtensionTheorem

/- Constructs the small magma SM, basic properties of the additional set N, and sets out the axioms these objects need to satisfy -/

namespace Eq1729

/- SM is the abelian group generated by countably many generators E n of order 4 -/

abbrev SM := DirectSum ℕ (fun _ ↦ ZMod 4)

open AddToMagma -- makes SM a magma automatically

instance SM_countable : Countable SM := by
  convert instCountableDFinsupp
  . infer_instance
  infer_instance

@[simp]
lemma SM_char_four (a : SM) : 4 • a = 0 := by
  apply DirectSum.ext_component ℤ
  intro i
  simp only [map_smul, map_zero]
  exact ZModModule.char_nsmul_eq_zero 4 _

abbrev E (n:ℕ) : SM := (DirectSum.of (fun _ ↦ ZMod 4) n) 1

@[simp]
lemma SM_op_eq_add (a b : SM) : a ◇ b = a + b := rfl

@[simp]
lemma E_apply (n m:ℕ) : E n m = if n=m then 1 else 0 := by
  simp [DirectSum.of_apply]

lemma E_inj : Function.Injective E := by
  intro n m h
  apply_fun (fun f ↦ f n) at h
  contrapose! h
  simp [E, DirectSum.of_eq_of_ne _ _ _ h.symm]
  decide

@[simp]
lemma E_ne_zero (n:ℕ): E n ≠ 0 := by
  by_contra! this
  apply_fun (fun f ↦ f n) at this
  simp only [DirectSum.of_eq_same, DirectSum.zero_apply] at this
  contrapose! this
  decide

/- The squaring map on SM -/
def S (a : SM) := a ◇ a

@[simp]
lemma S_zero : S 0 = 0 := rfl

lemma SM_square_eq_double (a : SM) : S a = a + a := rfl

@[simp]
lemma SM_square_square_eq_zero (a : SM) : S (S a) = 0 := by
  rw [← sub_eq_zero]
  simp only [SM_square_eq_double]
  abel_nf
  exact SM_char_four _

@[simp]
lemma S_neg (a : SM) : S (-a) = S a := by
  simp only [SM_square_eq_double]
  symm
  rw [← sub_eq_zero]
  abel_nf
  exact SM_char_four _

@[simp]
lemma S_add (a b: SM) : S (a + b) = S a + S b := by
  simp only [SM_square_eq_double]
  abel

@[simp]
lemma S_sub (a b: SM) : S (a - b) = S a + S b := by
  simp only [SM_square_eq_double]
  symm
  rw [← sub_eq_zero]
  abel_nf
  exact SM_char_four _

@[simp]
lemma S_eval (a : SM) (n:ℕ) : S a n = a n + a n := by
  simp [SM_square_eq_double]

lemma SM_obeys_1729 : Equation1729 SM := by
  intro x y
  simp only [SM_op_eq_add, SM_square_eq_double]
  symm
  rw [← sub_eq_zero]
  abel_nf
  exact SM_char_four _

lemma one_odd (n : ZMod 4) : 1 ≠ n + n := by
  revert n
  decide

lemma E_ne_S (n:ℕ) (a:SM) : E n ≠ S a := by
  by_contra! this
  apply_fun (fun f ↦ f n) at this
  simp [E,SM_square_eq_double, DirectSum.of_apply, one_odd] at this

lemma E_ne_SE (n m : ℕ): E n ≠ S (E m) := E_ne_S _ _

@[simp]
lemma SE_ne_zero (n:ℕ): S (E n) ≠ 0 := by
  by_contra! this
  apply_fun (fun f ↦ f n) at this
  simp only [SM_square_eq_double, DirectSum.add_apply, DirectSum.of_eq_same,
    DirectSum.zero_apply] at this
  contrapose! this
  decide

def L (a:SM) : SM ≃ SM := {
  toFun := fun x ↦ x + a
  invFun := fun x ↦ x - a
  left_inv := leftInverse_sub_add_left a
  right_inv := by
    intro x
    simp only [sub_add_cancel]
}

def R (a:SM) : SM ≃ SM := L a

/- N is the free group generated by e_a for each a in SM -/

abbrev N := FreeGroup SM

instance N_countable : Countable N := Quotient.countable

abbrev e (a:SM) := FreeGroup.of a

/-- For mathlib? -/
@[simp]
theorem FreeGroup.mk_of_single_true {α : Type* } (a : α) : FreeGroup.mk [(a,true)] = FreeGroup.of a := rfl

/-- For mathlib? -/
@[simp]
theorem FreeGroup.mk_of_single_false {α : Type*} (a : α) : FreeGroup.mk [(a,false)] = (FreeGroup.of a)⁻¹  := rfl

lemma div_eq (a b : SM) : (e b)⁻¹ * (e a)  = FreeGroup.mk ([(b, false)] ++ [(a,true)]) := by
    simp only [← FreeGroup.mul_mk, FreeGroup.mk_of_single_true, FreeGroup.mk_of_single_false, e]

lemma square_mul (a b : SM) : (e b) * (e a)^2 = FreeGroup.mk ([(b, true)] ++ [(a,true)] ++ [(a,true)]) := by
    simp only [← FreeGroup.mul_mk, FreeGroup.mk_of_single_true,  e]
    rw [mul_assoc]
    congr

lemma square (a : SM) : (e a)^2 = FreeGroup.mk ([(a,true)] ++ [(a,true)]) := by
    simp only [← FreeGroup.mul_mk, FreeGroup.mk_of_single_true,  e]
    congr

def adjacent (x y : N) := ∃ a, x = (e a) * y ∨ y = (e a) * x

lemma not_adjacent_self (x:N) : ¬ adjacent x x := by
  by_contra this
  simp only [adjacent, right_eq_mul, FreeGroup.of_ne_one, or_self, exists_const] at this

/-- Impose an order on N: x ≤ y if x is a right subword of y  (or equivalently, x is on the unique
simple path from 1 to y).  The spelling may not be optimal. -/
instance N_LE : LE N where
  le x y := x.toWord <:+ y.toWord

theorem le_def (x y : N) : (x ≤ y) = (x.toWord <:+ y.toWord) := rfl

instance N_order : PartialOrder N where
  le := N_LE.le
  le_refl _ := List.suffix_rfl
  le_trans _ _ _ := List.IsSuffix.trans
  le_antisymm x y hxy hyx := FreeGroup.toWord_injective <|
    List.IsSuffix.eq_of_length_le hxy (List.IsSuffix.length_le hyx)

def N_lt_hom_nat_lt: RelHom (fun x y : N => x < y) (fun x y : ℕ => x < y) := {
  toFun := fun x => x.toWord.length
  map_rel' := by
    intro x y h
    rw [lt_iff_le_not_le, le_def] at h
    have len_le := List.IsSuffix.length_le h.1
    have len_ne: x.toWord.length ≠ y.toWord.length := by
      by_contra!
      have word_eq := List.IsSuffix.eq_of_length_le h.1 (by exact Nat.le_of_eq (id (Eq.symm this)))
      simp [le_def, word_eq] at h
    exact Nat.lt_of_le_of_ne len_le len_ne
}

instance : WellFoundedLT N := {
  wf := RelHomClass.wellFounded N_lt_hom_nat_lt IsWellFounded.wf
}

instance : LocallyFiniteOrderBot N := LocallyFiniteOrderBot.ofIic
  (finsetIic := fun x => (List.map (FreeGroup.mk) x.toWord.tails).toFinset)
  (mem_Iic := fun a x => by
    simp only [List.mem_toFinset, List.mem_map, List.mem_tails, le_def]
    constructor
    · rintro ⟨a, h, eq⟩
      rw [← eq, FreeGroup.toWord_mk, FreeGroup.Red.reduced_iff_eq_reduce.mp]
      · exact h
      · exact FreeGroup.Red.reduced_infix (FreeGroup.reduced_toWord) h.isInfix
    · intro h
      use x.toWord
      simp [h, FreeGroup.mk_toWord])

/-- the parent of x is defined to be the unique element adjacent to x whose reduced word is shorter, with the junk convention that the parent of the identity is itself -/
def parent (x : N) : N := FreeGroup.mk x.toWord.tail

theorem parent_toWord (x : N) : (parent x).toWord = x.toWord.tail := by
  rw [parent, FreeGroup.toWord_mk, FreeGroup.Red.reduced_iff_eq_reduce.mp]
  exact FreeGroup.Red.reduced_infix (FreeGroup.reduced_toWord) (List.tail_suffix _).isInfix

@[simp]
lemma parent_one : parent 1 = 1 := by
  simp only [parent, FreeGroup.toWord_one, List.tail_nil]
  rfl

theorem parent_le (x : N) : parent x ≤ x := by
  rw [le_def, parent_toWord]
  exact List.tail_suffix _

theorem lt_iff_le_parent {x y : N} (h : y ≠ 1) : x < y ↔ x ≤ parent y := by
  rw [lt_iff_le_and_ne, le_def, le_def, parent_toWord]
  cases h' : y.toWord
  case nil =>
    simp only [List.suffix_nil, FreeGroup.toWord_eq_nil_iff, ne_eq, List.tail_nil,
    and_iff_left_iff_imp]
    exact fun a ↦ ne_of_eq_of_ne a (Ne.symm h)
  case cons head tail =>
    simp only [List.tail_cons, List.suffix_cons_iff]
    constructor
    · rintro ⟨(eq | h'), ineq⟩
      · exfalso
        apply ineq
        apply FreeGroup.toWord_injective
        rw [eq, h']
      · assumption
    · refine fun h'' ↦ ⟨Or.inr h'', fun eq' ↦ ?_⟩
      rw [eq', h'] at h''
      simpa using h''.length_le

instance : OrderBot N where
  bot := 1
  bot_le x := by simp [le_def]

theorem bot_eq_one : (⊥ : N) = 1 := rfl

instance : PredOrder N where
  pred := parent
  pred_le := parent_le
  min_of_le_pred hap := by
    rw [isMin_iff_eq_bot]
    rw [le_def, parent_toWord] at hap
    have := hap.length_le
    simp only [List.length_tail] at this
    rw [bot_eq_one, ← FreeGroup.toWord_eq_nil_iff, ← List.length_eq_zero_iff]
    omega
  le_pred_of_lt {a} {b} hab := (lt_iff_le_parent hab.ne_bot).mp hab

theorem parent_adjacent {x : N} (h : x ≠ 1) : adjacent x (parent x) := by
  cases h' : x.toWord
  case nil =>
    simp only [FreeGroup.toWord_eq_nil_iff] at h'
    exact (h h').elim
  case cons head tail =>
    have eq : x = FreeGroup.mk [head] * parent x := by
      rw [← FreeGroup.mk_toWord (x := parent x), parent_toWord, h', ← FreeGroup.mk_toWord (x := x),
      h']
      rfl
    nth_rw 1 [eq]
    rcases head with ⟨a,⟨⟩⟩
    · use a
      right
      have eq_inv : FreeGroup.mk [(a, false)] = (e a)⁻¹ := by
        simp only [e, FreeGroup.of, FreeGroup.inv_mk]
        rfl
      simp [eq_inv]
    · exact ⟨a, Or.symm (Or.inr rfl)⟩

theorem parent_lt {x : N} (h : x ≠ 1) : parent x < x := by
  rw [lt_iff_le_and_ne]
  constructor
  . exact parent_le x
  . intro eq
    have := parent_adjacent h
    rw [eq] at this
    exact not_adjacent_self x this

theorem adjacent_comm (x y : N) : adjacent x y ↔ adjacent y x := exists_congr (by tauto)

theorem parent_of_adjacent {x y : N} (h : adjacent x y) : x = parent y ∨ y = parent x := by
  obtain ⟨a, h⟩ := h
  wlog l : x = e a * y generalizing x y
  · rcases h with h | h
    · tauto
    exact or_comm.mp (this (.inl h) h)
  cases h : y.toWord
  case nil =>
    right
    simp only [FreeGroup.toWord_eq_nil_iff] at h
    rw [l,h]
    simp only [parent, mul_one, FreeGroup.toWord_of, List.tail_cons]
    rfl
  case cons head tail =>
    by_cases eq : head = ⟨a, false⟩
    · left
      have eq' : y = FreeGroup.mk [head] * parent y := by
        rw [← FreeGroup.mk_toWord (x := parent y), parent_toWord, h, ← FreeGroup.mk_toWord (x := y),
        h]
        rfl
      rw [l]
      nth_rw 1 [eq']
      have eq_inv : FreeGroup.mk [head] = (e a)⁻¹ := by
        simp only [eq, e, FreeGroup.of, FreeGroup.inv_mk]
        rfl
      simp [eq_inv]
    · right
      have eq' : x.toWord = (a, true) :: y.toWord := by
        rw [l, FreeGroup.toWord_mul, FreeGroup.Red.reduced_iff_eq_reduce.mp]
        · rfl
        · rw [h]
          apply FreeGroup.Red.reduced_cons.mpr
          rw [← h]
          simp only [FreeGroup.reduced_toWord, and_true]
          cases head
          simp only [Bool.not_true, Bool.false_eq, not_and, Bool.not_eq_false]
          intro eq'
          simpa [eq'] using eq
      apply FreeGroup.toWord_injective
      simp [parent_toWord, eq']

@[simp]
lemma parent_of_e_sq (a:SM) : parent ((e a)^2) = e a := by
  simp only [parent, e, FreeGroup.toWord_of_pow, List.reduceReplicate, List.tail_cons,
    FreeGroup.mk_of_single_true]

lemma parent_of_div {a b:SM} (h:a ≠ b) : parent ((e a)⁻¹ * e b) = e b := by
  simp [parent, e, div_eq, FreeGroup.reduce_nil, h]

/- Right-multiplication by an element of SM on N is defined via the group action. -/

def R' (a:SM) : N ≃ N := {
  toFun := fun x ↦ (e a) * x
  invFun := fun x ↦ (e a)⁻¹ * x
  left_inv := by
    intro x
    simp only [inv_mul_cancel_left]
  right_inv := by
    intro x
    simp only [mul_inv_cancel_left]
}

lemma R'_axiom_iia (a b : SM) (y:N) (h: a ≠ b): R' a y ≠ R' b y := by
  contrapose! h
  simp only [R', Equiv.coe_fn_mk, mul_left_inj] at h
  exact FreeGroup.of_injective h

@[simp]
lemma R'_axiom_iia' {a b : SM} {y:N} : R' a y = R' b y ↔ a = b := by
  refine ⟨fun h ↦ ?_, by aesop⟩
  contrapose! h
  exact R'_axiom_iia a b y h

lemma R'_axiom_iib (a : SM) (y:N) : R' a y ≠ y := by
  by_contra! h
  simp [R'] at h

lemma R'_adjacent (a : SM) (y:N) : adjacent y (R' a y) := ⟨a, Or.inr rfl⟩

/- Now we rewrite the axioms using a single transformation L₀' instead of many transformations L' -/

/- Not sure if this is the best spelling for this axiom -/
def axiom_i' (L₀' : N → N) : Prop := L₀' ∘ L₀' = (R' 0).symm

lemma L₀'_R'0_L₀'_eq_id {L₀' : N → N} (h: axiom_i' L₀') : L₀' ∘ R' 0 ∘ L₀' = id := by
  unfold axiom_i' at h
  calc
    _ = L₀' ∘ R' 0 ∘ L₀' ∘ ((L₀' ∘ L₀') ∘ R' 0) := by aesop
    _ = (L₀' ∘ (R' 0 ∘ (L₀' ∘ L₀')) ∘ L₀') ∘ R' 0 := rfl
    _ = _ := by simp [h]

def L' {L₀' : N → N} (h: axiom_i' L₀') (a:SM) : N ≃ N := {
  toFun := (R' a).symm ∘ L₀' ∘  R' (S a)
  invFun := (R' (S a)).symm ∘ L₀' ∘ (R' 0) ∘  (R' a)
  left_inv := by
    rw [Function.leftInverse_iff_comp]
    calc
      _ = (R' (S a)).symm ∘ L₀' ∘ R' 0 ∘ (R' a ∘ (R' a).symm) ∘ L₀' ∘ R' (S a) := rfl
      _ = (R' (S a)).symm ∘ (L₀' ∘ R' 0 ∘ L₀') ∘ R' (S a) := by aesop
      _ = _ := by simp [L₀'_R'0_L₀'_eq_id h]
  right_inv := by
    unfold axiom_i' at h
    rw [Function.rightInverse_iff_comp]
    calc
      _ = (R' a).symm ∘ ((L₀' ∘ (R' (S a) ∘ (R' (S a)).symm) ∘ L₀') ∘ R' 0) ∘ R' a := rfl
      _ = _ := by simp [h]
}

lemma L'_0_eq_L₀' {L₀' : N → N} (h: axiom_i' L₀') : L' h 0 = L₀' := by
  unfold axiom_i' at h
  simp only [L', ← h, SM_square_eq_double, add_zero, Equiv.coe_fn_mk]
  rw [Function.comp_assoc, ← Function.comp_assoc _ _ (R' 0), h]
  simp

abbrev M := SM ⊕ N

variable (f g h : ℕ → ℕ)

example : ℕ := f $ g $ h 0

abbrev axiom_iii' (S': N → SM) (L₀' : N → N)  := ∀ (a : SM) (x y : N), R' a x = y → ((R' (S' y)).symm $ L₀' $ R' (S (S' y)) $ (R' (a - S' x)).symm $ L₀' $ R' (S (a - S' x)) y) = x
-- axiom_3 : ∀ x y, ∀ a, R' a x = y → ((L' (S' y)) (L' ((L (S' x)).symm a) y)) = x

abbrev axiom_iv' (S': N → SM) (L₀' : N → N) := ∀ x : N, ((R' (S' x)).symm $ L₀' $ R' (S (S' x)) $ (R' (S' x)).symm $ L₀' $ R' (S (S' x)) $ x) = x

abbrev axiom_v (S': N → SM) (op: N → N → M) := ∀ x : N, op x x = Sum.inl (S' x)

abbrev axiom_vi' (S': N → SM) (op: N → N → M) := ∀ (y : N) (a : SM), op (R' a y) y = Sum.inl (a - S' y)

abbrev axiom_vii' (S': N → SM) (L₀' : N → N) (op: N → N → M) := ∀ x y : N, x ≠ y → (∀ a : SM, x ≠ R' a y) → ∃ z : N, op x y = Sum.inr z ∧ op z x = Sum.inr ((R' (S (S' x))).symm $ L₀' $ R' 0 $ R' (S' x) $ y)

lemma reduce_to_new_axioms {S': N → SM} {L₀' : N → N} {op: N → N → M} (h_i': axiom_i' L₀') (h_iii': axiom_iii' S' L₀') (h_iv': axiom_iv' S' L₀') (h_v: axiom_v S' op) (h_vi': axiom_vi' S' op) (h_vii': axiom_vii' S' L₀' op) : ∃ (G: Type) (_: Magma G), Equation1729 G ∧ ¬ Equation817 G := by
  suffices : ExtOpsWithProps SM N
  . exact ⟨ M, extMagmaInst this, ExtMagma_sat_eq1729 this, ExtMagma_unsat_eq817 this ⟩
  exact
   {
    S := S
    L := L
    R := R
    S' := S'
    L' := (fun a ↦ L' h_i' a)
    R' := (fun a ↦ R' a)
    rest_map := op
    squaring_prop_SM := fun _ ↦ rfl
    left_map_SM := by
      intro x y
      simp [Equiv.coe_fn_mk, SM_op_eq_add, L, AddCommMonoid.add_comm]
    right_map_SM := fun x y ↦ rfl
    SM_sat_1729 := SM_obeys_1729
    axiom_1 := by
      intro a x
      simp [L', SM_square_square_eq_zero, Equiv.coe_fn_mk]
      have h' := L₀'_R'0_L₀'_eq_id h_i'
      set y := R' (S a) x with hy
      simp [Function.comp_def] at h'
      have h'' : ∀ y, (fun x ↦ L₀' ((R' 0) (L₀' x))) y = y := fun _ ↦ h' ▸ rfl
      specialize h'' y
      simp only at h''
      calc
        _ = (L₀' ∘ (R' 0).symm ∘ (R' 0)) y := by simp
        _ = _ := h_i' ▸ rfl
    axiom_21 := fun a b y h ↦ R'_axiom_iia a b y h
    axiom_22 := fun a x ↦ R'_axiom_iib a x
    axiom_3 := fun x y a h ↦ h_iii' a x y h
    axiom_4 := by intro x; simp [L', h_iv' x]
    axiom_5 := fun x ↦ h_v x
    axiom_6 := fun y a ↦ h_vi' y a
    axiom_7 := by aesop
   }

-- Remark: a lot of the definitions and API below could be restated more abstractly using the quotient space construction on groups.  This might be worth doing in order to locate some further contributions to Mathlib in this area.

instance rel : Setoid N := {
  r := fun x y => ∃ n : ℤ, y = (e 0)^n * x
  iseqv := by
    refine ⟨fun _ ↦ ⟨0, by simp [zpow_zero, one_mul]⟩, ?_, ?_⟩
    . intro x y ⟨ n, h1 ⟩
      exact ⟨-n, by rw [h1, ← mul_assoc, ← zpow_add, neg_add_cancel, zpow_zero, one_mul]⟩
    . intro x y z ⟨ n, h1 ⟩ ⟨ m, h2 ⟩
      exact ⟨n + m, by rw [h2, h1, ← mul_assoc, add_comm, zpow_add]⟩
}

lemma rel_iff (x y:N): x ≈ y ↔ ∃ n : ℤ, y = (e 0)^n * x := by rfl

lemma rel_def {x y:N} (h: x ≈ y) : ∃ n : ℤ, y = (e 0)^n * x := (rel_iff x y).mp h

lemma rel_of_mul (x:N) (n:ℤ) : x ≈ (e 0)^n * x := ⟨n, rfl⟩

lemma rel_of_R0 (x:N) : x ≈ R' 0 x := rel_of_mul x 1

/-- `fill D` is the set of elements of the form (e 0)^n x with x in D and n an integer. -/
def fill (D: Finset N) : Set N := { y | ∃ x, x ≈ y ∧ x ∈ D }

@[simp]
lemma fill_empty : fill Finset.empty = ∅ := by
  ext y
  simp only [fill, Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false, not_exists, not_and]
  exact fun _ _ ↦ Finset.notMem_empty _

lemma fill_mono {D₁ D₂ : Finset N} (h : D₁ ⊆ D₂) : fill D₁ ⊆ fill D₂ := by
  intro y hy
  rcases hy with ⟨x, hx, hD⟩
  exact ⟨x, hx, h hD⟩

@[simp]
lemma fill_union {D₁ D₂ : Finset N} : fill (D₁ ∪ D₂) = (fill D₁) ∪ (fill D₂) := by
  ext y
  simp only [fill, Finset.mem_union, Set.mem_setOf_eq, Set.mem_union]
  aesop

@[simp]
lemma fill_pair {x y : N} : fill {x,y} = (fill {x}) ∪ (fill {y}) := by
  convert fill_union using 2
  rfl

@[simp]
lemma fill_singleton {x y : N} : x ∈ fill {y} ↔ x ≈ y := by
  simp only [fill, Finset.mem_singleton, exists_eq_right, Set.mem_setOf_eq]
  exact Setoid.comm' _

lemma fill_invar (D: Finset N) {x y : N} (h : x ≈ y) : x ∈ fill D ↔ y ∈ fill D := by
  constructor <;> intro h; simp only [fill, Set.mem_setOf_eq] at h ⊢;
  . obtain ⟨ z, hz, hD ⟩ := h
    exact ⟨ z, Setoid.trans hz h, hD ⟩
  · obtain ⟨ z, hz, hD ⟩ := h
    exact ⟨ z, Setoid.trans hz (Setoid.symm h), hD ⟩

@[simp]
lemma fill_invar' (D: Finset N) (x:N) (n:ℤ) : (e 0)^n * x ∈ fill D ↔ x ∈ fill D :=
  (fill_invar D (rel_of_mul x n)).symm

lemma subset_fill (D: Finset N) : D.toSet ⊆ fill D := fun x hx ↦ ⟨x, Setoid.refl x, hx⟩

lemma mem_fill {D: Finset N} {x:N} (hx: x ∈ D) : x ∈ fill D := subset_fill D hx

@[simp]
lemma R0_mem_fill_iff (D: Finset N) (x:N) : R' 0 x ∈ fill D ↔ x ∈ fill D :=
  (fill_invar D (rel_of_R0 x)).symm






-- `generators A` are all the indices in ℕ involved in a finite set `A` of elements of `SM`
abbrev generators (A : Finset SM) : Finset ℕ := A.biUnion DFinsupp.support ∪ {0}

lemma generators_mono {A B : Finset SM} (h: A ⊆ B) : generators A ⊆ generators B := by
  unfold generators
  gcongr
  exact Finset.biUnion_subset_biUnion_of_subset_left DFinsupp.support h

/-- For Mathlib? -/
lemma Finset.biUnion_union {α : Type*} {β : Type*} {s s' : Finset α} {t : α → Finset β} [DecidableEq β] [DecidableEq α]  :
(s ∪ s').biUnion t = (s.biUnion t) ∪ (s'.biUnion t) := by
  ext _
  simp only [Finset.mem_biUnion, Finset.mem_union]
  aesop

lemma generators_union (A B : Finset SM) : generators (A ∪ B) = generators A ∪ generators B := calc
  _ = A.biUnion DFinsupp.support ∪ B.biUnion DFinsupp.support ∪ ({0} ∪ {0}) := by
    simp [generators]
    rw [←Finset.union_assoc]
    congr 1
    exact Finset.biUnion_union
  _ = (A.biUnion DFinsupp.support ∪ {0}) ∪ (B.biUnion DFinsupp.support ∪ {0}) := by ac_rfl
  _ = _ := rfl

abbrev in_generators (A : Finset SM) (a : SM) := a.support ⊆ generators A

lemma zero_in_generators (A : Finset SM): 0 ∈ generators A := Finset.mem_union_right _ (Finset.mem_singleton.mpr rfl)

lemma zero_in_generators' (A : Finset SM): in_generators A 0 := Finset.inter_eq_left.mp rfl

lemma generators_subset_iff {A B : Finset SM} : generators A ⊆ generators B ↔ ∀ a ∈ A, in_generators B a := by
  constructor
  . intro h a ha n hn
    exact h $ Finset.mem_union_left _ $ Finset.subset_biUnion_of_mem DFinsupp.support ha hn
  intro h n hn
  simp only [generators, Finset.mem_union,
    Finset.mem_singleton, Finset.mem_biUnion] at hn
  rcases hn with ⟨ a, ha, han ⟩ | hn
  . exact h a ha han
  rw [hn]
  exact zero_in_generators B

@[simp]
lemma support_E (d:ℕ) : (E d).support = {d} := by
  rw [DirectSum.support_of]
  exact Ne.symm (ne_of_beq_false rfl)

lemma E_in_generators {A : Finset SM} {d: ℕ} (h: d ∈ generators A) : in_generators A (E d) := by
  rwa [in_generators, support_E, Finset.singleton_subset_iff]

@[simp]
lemma E_in_generators_iff (A:Finset SM) (d: ℕ) :  in_generators A (E d) ↔ d ∈ generators A := by
  constructor
  . intro h
    rwa [in_generators, support_E, Finset.singleton_subset_iff] at h
  exact E_in_generators


lemma not_in_generators {A : Finset SM} {a : SM} (h: in_generators A a) {n:ℕ} (hn: ¬ n ∈ generators A): a n = 0 := by
  contrapose! hn
  rw [← DFinsupp.mem_support_toFun] at hn
  exact Finset.mem_of_subset h hn

lemma generators_nonempty (A : Finset SM): (generators A).Nonempty := ⟨ 0, zero_in_generators A ⟩

lemma mem_in_generators {A : Finset SM} {a : SM} (h: a ∈ A) : in_generators A a := by
  exact (Finset.subset_biUnion_of_mem _ h).trans Finset.subset_union_left

lemma sum_in_generators {A : Finset SM} {a b : SM} (ha: in_generators A a) (hb: in_generators A b) : in_generators A (a+b) := by
  intro n hn
  simp only [DFinsupp.mem_support_toFun, DirectSum.add_apply, ne_eq] at hn
  contrapose! hn
  simp only [not_in_generators ha hn, not_in_generators hb hn, add_zero]

lemma S_in_generators {A : Finset SM} {a : SM} (ha: in_generators A a) : in_generators A (S a) := sum_in_generators ha ha

lemma diff_in_generators {A : Finset SM} {a b : SM} (ha: in_generators A a) (hb: in_generators A b) : in_generators A (a-b) := by
  intro n hn
  simp only [DFinsupp.mem_support_toFun, DirectSum.sub_apply, ne_eq] at hn
  contrapose! hn
  simp only [not_in_generators ha hn, not_in_generators hb hn, sub_zero]

-- a fresh generator that does not appear in A
abbrev fresh (A: Finset SM) (n:ℕ) : ℕ := ((generators A).max' (generators_nonempty A)) + (n + 1)

lemma fresh_ne_fresh (A: Finset SM) (n m:ℕ) (h: n ≠ m) : fresh A n ≠ fresh A m := by
  contrapose! h
  rwa [add_right_inj, add_left_inj] at h

lemma fresh_ne_generator (A: Finset SM) (n:ℕ) : ¬ (fresh A n) ∈ generators A := by
  by_contra! h
  linarith [Finset.le_max' _ _ h]

lemma fresh_not_in_generators (A: Finset SM) (n:ℕ) : ¬ in_generators A (E (fresh A n)) := by
  simp only [in_generators, support_E, Finset.singleton_subset_iff]
  exact fresh_ne_generator A n

lemma Sfresh_not_in_generators (A: Finset SM) (n:ℕ) : ¬ (in_generators A $ S $ E $ fresh A n) := by
  simp only [in_generators, Finset.not_subset]
  refine ⟨ _, ?_, fresh_ne_generator A n ⟩
  rw [DFinsupp.mem_support_iff]
  simp only [S, E, SM_op_eq_add, DirectSum.add_apply, DirectSum.of_eq_same, ne_eq]
  decide


lemma fresh_injective (A: Finset SM) : Function.Injective (fresh A) := by
  intros n m h
  unfold fresh at h
  linarith


/-- The basis elements of an element `x` of the free group `N` are the set of indices `a` of the generators `e a` appearing in the minimal word of `x`, together with `0`. -/
abbrev basis_elements (x:N) : Finset SM := Finset.image (fun (a, _) ↦ a) x.toWord.toFinset ∪ {0}

abbrev basis_elements' (x:M) : Finset SM := match x with
  | Sum.inl a => {a}
  | Sum.inr x => basis_elements x

@[simp]
lemma basis_elements_of_id : basis_elements 1 = {0} := by
  simp only [Finset.union_eq_right, FreeGroup.toWord_one, List.toFinset_nil, Finset.image_empty,
    Finset.subset_singleton_iff, true_or]

@[simp]
lemma zero_mem_basis_elements (x:N) : 0 ∈ basis_elements x := by
  simp only [basis_elements, Finset.mem_union, Finset.mem_image, List.mem_toFinset, Prod.exists,
    exists_and_right, Bool.exists_bool, exists_eq_right, Finset.mem_singleton, or_true]

@[simp]
lemma basis_elements_of_generator (a: SM) : basis_elements (e a) = {a,0} := by
  simp only [basis_elements, FreeGroup.toWord_of, List.toFinset_cons, List.toFinset_nil,
    insert_empty_eq, Finset.image_singleton]
  rfl

/-- For Mathlib? -/
lemma List.replicate_toFinset {α : Type*} [DecidableEq α] (a : α) {n : Nat} (hn: n ≠ 0) : (List.replicate n a).toFinset = {a} := by
  ext _
  simp only [List.mem_toFinset, List.mem_replicate, ne_eq, hn, not_false_eq_true, true_and,
    Finset.mem_singleton]

@[simp]
lemma basis_elements_of_generator_pow (a: SM) {n:ℕ} (hn: n ≠  0): basis_elements ((e a)^n) = {a,0} := by
  unfold basis_elements
  classical
  simp only [FreeGroup.toWord_of_pow, List.replicate_toFinset (a,true) hn]
  change Finset.image (fun x ↦ x.1) {(a,true)} ∪ {0} = {a} ∪ {0}
  congr

lemma basis_elements_of_prod_gen (a b:SM) : a ∈ basis_elements ((e b)⁻¹ * (e a)^2) := by
  by_cases h : b = a
  . rw [← h]
    group
    simp only [basis_elements_of_generator, Finset.mem_insert, Finset.mem_singleton, true_or]
  simp only [basis_elements, Finset.mem_union, Finset.mem_image, List.mem_toFinset, Prod.exists,
    exists_and_right, Bool.exists_bool, exists_eq_right, Finset.mem_singleton]
  left; right
  have : (e b)⁻¹ * (e a)^2  = FreeGroup.mk ([(b, false)] ++ [(a,true)] ++ [(a,true)]) := by
    simp only [← FreeGroup.mul_mk, FreeGroup.mk_of_single_true, FreeGroup.mk_of_single_false, e]
    rw [mul_assoc]
    congr
-- weirdly, the simp below breaks when using the recommend simp?
  simp [this, h]

lemma basis_elements_of_prod_gen' (a b:SM) : a ∈ basis_elements ((e b) * (e a)^2) := by
  by_cases h : b = a
  . rw [← h]
    group
    change b ∈ basis_elements (e b ^ (3:ℕ))
    have : 3 ≠ 0 := by norm_num
    simp only [basis_elements_of_generator_pow b this, Finset.mem_insert, Finset.mem_singleton, true_or]
  simp only [basis_elements, Finset.mem_union, Finset.mem_image, List.mem_toFinset, Prod.exists,
    exists_and_right, Bool.exists_bool, exists_eq_right, Finset.mem_singleton]
  left; right
  simp [square_mul a b, h]

lemma FreeGroup.div_ne_square (a b c:SM) : (e b)⁻¹ * (e a) ≠ (e c)^2 := by
  by_contra h
  apply_fun (fun x ↦ x.toWord) at h
  rw [div_eq a b] at h
  simp only [List.singleton_append, FreeGroup.toWord_mk, FreeGroup.reduce.cons, Bool.true_eq,
    Bool.not_eq_eq_eq_not, Bool.not_true, Bool.false_eq, Bool.not_false, FreeGroup.reduce_nil,
    and_true, e, FreeGroup.toWord_of_pow, List.reduceReplicate] at h
  by_cases h1 : b=a
  . simp only [h1, ↓reduceIte, List.nil_eq, reduceCtorEq] at h
  simp only [h1, ↓reduceIte, List.cons.injEq, Prod.mk.injEq, Bool.false_eq_true, and_false,
    and_true, false_and] at h


lemma FreeGroup.div_ne_square_mul (a b c d:SM) : (e b)⁻¹ * (e a) ≠ (e d) * (e c)^2 := by
  by_contra h
  rw [square_mul c d, div_eq a b] at h
  apply_fun (fun x ↦ x.toWord) at h
  simp at h
  by_cases h1 : b = a
  . simp only [h1, ↓reduceIte, List.nil_eq, reduceCtorEq] at h
  simp only [h1, ↓reduceIte, List.cons.injEq, Prod.mk.injEq, Bool.false_eq_true, and_false,
    and_true, List.ne_cons_self, and_self] at h


lemma basis_elements_of_mul (x y:N): basis_elements (x * y) ⊆ basis_elements x ∪ basis_elements y := by
  unfold basis_elements
  simp only [Finset.union_assoc]
  rw [Finset.union_comm {0} _, Finset.union_assoc, Finset.union_idempotent, ← Finset.union_assoc, ← Finset.image_union]
  gcongr
  apply Finset.image_subset_image
  intro n hn
  simp at hn ⊢
  replace hn := List.Sublist.mem hn (FreeGroup.toWord_mul_sublist x y)
  rwa [List.mem_append] at hn


/-- For Mathlib? -/
@[simp]
lemma List.toFinset_map {α β: Type*} [DecidableEq α] [DecidableEq β] (l: List α) (f : α → β) : (List.map f l).toFinset = Finset.image f l.toFinset := by
  ext a
  simp_all only [List.mem_toFinset, List.mem_map, Finset.mem_image]


@[simp]
lemma basis_elements_of_inv (x:N) : basis_elements x⁻¹ = basis_elements x := by
  unfold basis_elements
  congr 1
  simp only [FreeGroup.toWord_inv, FreeGroup.invRev, List.toFinset_reverse, List.toFinset_map, Finset.image_image]
  congr

@[simp]
lemma basis_elements_of_genzero_pow' (n: ℕ) : basis_elements ((e 0)^n) = {0} := by
  unfold basis_elements
  classical
  simp only [FreeGroup.toWord_of_pow, Finset.union_eq_right, Finset.subset_singleton_iff,
    Finset.image_eq_empty, List.toFinset_eq_empty_iff, List.replicate_eq_nil_iff]
  rw [Decidable.or_iff_not_imp_left]
  intro hn
  ext m
  simp only [Finset.mem_image, List.mem_toFinset, List.mem_replicate, ne_eq, hn, not_false_eq_true,
    true_and, eq_comm, exists_eq_left, Finset.mem_singleton]

@[simp]
lemma basis_elements_of_genzero_pow (n: ℤ) : basis_elements ((e 0)^n) = {0} := match n with
 | Int.ofNat m => by simp
 | Int.negSucc m => by simp

lemma basis_elements_of_rel' {x y:N} (h: x ≈ y) : basis_elements x ⊆ basis_elements y := by
  obtain ⟨ n, hn ⟩ := rel_def (Setoid.symm h)
  rw [hn]
  apply (basis_elements_of_mul _ _).trans
  rw [basis_elements_of_genzero_pow]
  simp only [Finset.union_subset_iff, Finset.subset_union_right, subset_refl, and_self]

lemma basis_elements_of_rel {x y:N} (h: x ≈ y) : basis_elements x = basis_elements y := by
  ext a
  constructor
  . intro h2
    exact basis_elements_of_rel' h h2
  intro h2
  exact basis_elements_of_rel' (Setoid.symm h) h2

abbrev val (a : SM) (x : N) : ℤ := Multiplicative.toAdd $ FreeGroup.lift (fun b ↦ if b=a then Multiplicative.ofAdd 1 else Multiplicative.ofAdd  0) x

@[simp]
lemma val_hom (a : SM) (x y : N): val a (x*y) = val a x + val a y := by
  simp only [val, ofAdd_zero, map_mul]
  rfl

@[simp]
lemma val_inv (a : SM) (x : N): val a x⁻¹ = -val a x := by
  simp only [val, ofAdd_zero, map_inv]
  rfl

@[simp]
lemma val_zpow (a : SM) (x : N) (n : ℤ) : val a (x^n) = n * val a x := by
  simp [val]

@[simp]
lemma val_e (a b : SM) : val a (e b) = if b=a then 1 else 0 := by
  simp only [val, ofAdd_zero, e, FreeGroup.lift.of]
  rfl

@[simp]
lemma val_mk (a b: SM) (t:Bool)  : val a (FreeGroup.mk [(b,t)]) = if b=a then (if t then 1 else -1) else 0 := by
  rcases t
  all_goals by_cases h:b=a
  all_goals simp [val,h]

@[simp]
lemma val_one (a:SM) : val a 1 = 0 := by
  simp only [val, ofAdd_zero, map_one, toAdd_one]

lemma FreeGroup.head_concat_tail {α:Type*} (head:α) (tail:List α) : [head] ++ tail = head :: tail := rfl

lemma val_of_nonsupp_eq_zero' {a:SM} {L:List (SM × Bool)} (h: ∀ b : Bool, (a,b) ∉ L.toFinset) : val a (FreeGroup.mk L) = 0 := match L with
| List.nil => by
    simp only [toAdd_eq_zero, ofAdd_zero, FreeGroup.lift.mk, List.map_nil, List.prod_nil]
| List.cons head tail => by
    have h1 : head.1 ≠ a := by
      contrapose! h
      use head.2
      simp only [List.toFinset_cons, ← h, Prod.mk.eta, Finset.mem_insert, List.mem_toFinset, true_or]
    have h2 : ∀ b : Bool, (a,b) ∉ tail.toFinset := by
      intro b
      replace h := h b
      contrapose! h
      simp only [List.mem_toFinset, List.toFinset_cons, Finset.mem_insert] at h ⊢
      exact Or.inr h
    rw [← FreeGroup.head_concat_tail, ← FreeGroup.mul_mk, val_hom, val_mk, val_of_nonsupp_eq_zero' h2]
    simp [h1]

lemma val_of_nonbasis_eq_zero {a:SM} {y:N} (h: a ∉ basis_elements y) : val a y = 0 := by
  rw [← y.mk_toWord]
  apply val_of_nonsupp_eq_zero'
  contrapose! h
  simp only [List.mem_toFinset] at h
  apply Finset.subset_union_left
  simp only [Finset.mem_image, List.mem_toFinset, Prod.exists, exists_and_right, exists_eq_right, h]

lemma val_of_nonsupp_eq_zero {a:SM} {y:N} (h: ¬ a.support ⊆  generators (basis_elements y)) : val a y = 0 := by
  apply val_of_nonbasis_eq_zero
  contrapose! h
  exact mem_in_generators h

lemma R'_R'_neq (a b : SM) (y:N) : R' a (R' b y) ≠ y := by
  by_contra! h
  apply_fun (fun z ↦ val a z) at h
  by_cases heq : b = a
  all_goals simp [R', heq] at h
  linarith

lemma basis_elements_parent_subset {x:N} : basis_elements (parent x) ⊆ basis_elements x := by
  refine Finset.union_subset_union (Finset.image_subset_image ?_) (fun _ a ↦ a)
  rw [parent_toWord]
  rcases x.toWord with ⟨ ⟩ | ⟨ a, l' ⟩ <;> simp

lemma shift_from_parent_mem_basis {x:N} {a:SM} (h: x = R' a (parent x)) : a ∈ basis_elements x := by
  by_cases h' : a ∈ basis_elements (parent x)
  . exact basis_elements_parent_subset h'
  apply_fun val a at h
  by_contra! h''
  simp [R', val_of_nonbasis_eq_zero h',  val_of_nonbasis_eq_zero h''] at h

lemma shift_to_parent_mem_basis {x:N} {a:SM} (h: R' a x = parent x) : a ∈ basis_elements x := by
  by_cases h' : a ∈ basis_elements (parent x)
  . exact basis_elements_parent_subset h'
  apply_fun val a at h
  by_contra! h''
  simp [R', val_of_nonbasis_eq_zero h',  val_of_nonbasis_eq_zero h''] at h

-- Time for some representation theory!

abbrev V := ℝ × ℝ

noncomputable abbrev T₁ : V ≃ₗ[ℝ] V := {
  toFun := fun (x,y) ↦ (x+y,y)
  invFun := fun (x,y) ↦ (x-y,y)
  map_add' := by
    intros
    simp only [Prod.mk_add_mk, Prod.mk.injEq, and_true]
    abel
  map_smul' := by
    intros
    simp only [smul_eq_mul, RingHom.id_apply, Prod.smul_mk, Prod.mk.injEq, and_true]
    ring
  left_inv := by
    intro (_,_)
    simp only [add_sub_cancel_right]
  right_inv := by
    intro (_,_)
    simp only [sub_add_cancel]
}

noncomputable abbrev T₂ : V ≃ₗ[ℝ] V := {
  toFun := fun (x,y) ↦ (y,x)
  invFun := fun (x,y) ↦ (y,x)
  map_add' := by
    intros
    simp only [Prod.mk_add_mk, Prod.mk.injEq, and_true]
  map_smul' := by
    intros
    simp only [smul_eq_mul, RingHom.id_apply, Prod.smul_mk, Prod.mk.injEq, and_true]
  left_inv := by
    intro (_,_)
    simp only
  right_inv := by
    intro (_,_)
    simp only
}

noncomputable abbrev pre_repr (a:SM) : N →* ( V ≃ₗ[ℝ] V) := FreeGroup.lift (fun b ↦ if b=a then T₂ else T₁)

noncomputable abbrev repr (a:SM) : Representation ℝ N V := MonoidHom.comp LinearEquiv.automorphismGroup.toLinearMapMonoidHom $ pre_repr a

lemma repr_eq_pre_repr (a:SM) (x:N) (v:V) : repr a x v = pre_repr a x v := by
  simp only [MonoidHom.coe_comp, Function.comp_apply,
    LinearEquiv.automorphismGroup.toLinearMapMonoidHom_apply, LinearEquiv.coe_coe]

lemma repr_of_self (a:SM) : repr a (e a) = T₂ := by
  simp only [repr, MonoidHom.coe_comp, Function.comp_apply, FreeGroup.lift.of, ↓reduceIte,
    LinearEquiv.automorphismGroup.toLinearMapMonoidHom_apply]

lemma repr_of_self_pow (a:SM) (n:ℤ) : repr a ((e a) ^ n) = (T₂ ^ n : V ≃ₗ[ℝ] V) := by
  simp only [MonoidHom.coe_comp, Function.comp_apply, map_zpow, FreeGroup.lift.of, ↓reduceIte,
    LinearEquiv.automorphismGroup.toLinearMapMonoidHom_apply]

lemma T₁_fixes : T₁ (1,0) = (1,0) := by
  simp [T₁, LinearEquiv.coe_mk]

lemma T₁_inv_fixes : T₁.symm (1,0) = (1,0) := by
  simp [T₁, LinearEquiv.coe_symm_mk]

/-- When mathlib is bumped, replace this with LinearEquiv.mul_apply -/
@[simp]
lemma LinearEquiv.mul_apply (S T : V ≃ₗ[ℝ] V) (v : V) : (S * T) v = S (T v) := rfl

/-- Not in Mathlib for some reason. -/
@[simp]
lemma LinearEquiv.inv_eq_symm {R : Type*} {E:Type*} [Semiring R] [SeminormedAddCommGroup E] [Module R E] (S : E ≃ₗ[R] E) : S⁻¹ = S.symm := rfl

lemma T₁_pow_acts (n:ℕ) : (T₁ ^ n) (0,1) = ((n:ℝ),1) := by
  induction' n with n hn
  . simp only [pow_zero, LinearEquiv.coe_one, id_eq, CharP.cast_eq_zero]
  rw [add_comm, pow_add, LinearEquiv.mul_apply, hn, pow_one]
  simp [T₁, LinearEquiv.coe_mk, add_comm, Nat.cast_add, Nat.cast_one]

lemma T₁_inv_pow_acts (n:ℕ) : (T₁⁻¹ ^ n) (0,1) = (-(n:ℝ),1) := by
  induction' n with n hn
  . simp only [pow_zero, LinearEquiv.coe_one, id_eq, CharP.cast_eq_zero, neg_zero]
  rw [add_comm, pow_add, LinearEquiv.mul_apply, hn, pow_one]
  simp only [T₁, LinearEquiv.inv_eq_symm, LinearEquiv.coe_symm_mk, Nat.cast_add, Nat.cast_one,
    neg_add_rev, Prod.mk.injEq, and_true]
  abel

@[simp]
lemma T₁_zpow_acts (n:ℤ) : (T₁ ^ n) (0,1) = ((n:ℝ),1) := by
  rcases n with n | n
  . simp [T₁_pow_acts]
  rw [zpow_negSucc, Int.cast_negSucc, ←inv_pow, T₁_inv_pow_acts]

lemma T₁_pow_fixes (n:ℕ) : (T₁ ^ n) (1,0) = (1,0) := by
  induction' n with n hn
  . simp only [pow_zero, LinearEquiv.coe_one, id_eq, CharP.cast_eq_zero]
  rw [add_comm, pow_add, LinearEquiv.mul_apply, hn, pow_one]
  simp [T₁, LinearEquiv.coe_mk, add_comm, zero_add]

lemma T₁_inv_pow_fixes (n:ℕ) : (T₁⁻¹ ^ n) (1,0) = (1,0) := by
  induction' n with n hn
  . simp only [pow_zero, LinearEquiv.coe_one, id_eq, CharP.cast_eq_zero, neg_zero]
  rw [add_comm, pow_add, LinearEquiv.mul_apply, hn, pow_one]
  simp only [T₁, LinearEquiv.inv_eq_symm, LinearEquiv.coe_symm_mk, Nat.cast_add, Nat.cast_one,
    neg_add_rev, Prod.mk.injEq, and_true]
  abel

@[simp]
lemma T₁_zpow_fixes (n:ℤ) : (T₁ ^ n) (1,0) = (1,0) := by
  rcases n with n | n
  . simp [T₁_pow_fixes]
  rw [zpow_negSucc, ←inv_pow, T₁_inv_pow_fixes]

lemma T₂_acts : T₂ (1,0) = (0,1) := by
  simp [T₂, LinearEquiv.coe_mk]

lemma nonbasis_fixes' {a:SM} {L:List (SM × Bool)} (h: ∀ b : Bool, (a,b) ∉ L.toFinset) : pre_repr a (FreeGroup.mk L) (1,0) = (1,0) := match L with
| List.nil => by
    simp only [FreeGroup.lift.mk, LinearEquiv.inv_eq_symm, List.map_nil, List.prod_nil,
      LinearEquiv.coe_one, id_eq]
| List.cons ⟨ a₀', b₀' ⟩ tail => by
    have h' : ∀ b : Bool, (a,b) ∉ tail.toFinset := by
      intro b
      replace h := h b
      contrapose! h
      simp only [List.mem_toFinset, List.toFinset_cons, Finset.mem_insert] at h ⊢
      exact Or.inr h
    have h'' : a₀' ≠ a := by
      contrapose! h
      use b₀'
      simp only [List.toFinset_cons, ← h, Prod.mk.eta, Finset.mem_insert, List.mem_toFinset, true_or]
    rw [←FreeGroup.head_concat_tail, ←FreeGroup.mul_mk, MonoidHom.map_mul, LinearEquiv.mul_apply, nonbasis_fixes' h']
    rcases b₀'
    all_goals simp [h'']

lemma nonbasis_fixes {a:SM} {x:N} (h: a ∉ basis_elements x) : pre_repr a x (1,0) = (1,0) := by
  rw [← x.mk_toWord]
  apply nonbasis_fixes'
  contrapose! h
  apply Finset.mem_union_left
  simp only [List.mem_toFinset] at h
  simp only [Finset.mem_image, List.mem_toFinset, Prod.exists, exists_and_right,
    exists_eq_right, h]



lemma cancel_lemma {a:SM} {x y:N} {n:ℤ} (hx: a ∉ basis_elements x) (hy: a ∉ basis_elements y) (h: (e a) * x = (e 0)^n * ((e a) * y)) : n = 0 := by
  apply_fun (fun x ↦ repr a x (1,0)) at h
  have hneq : 0 ≠ a := by
    contrapose! hx
    rw [←hx]
    exact zero_mem_basis_elements x
  symm at h
  simp only [MonoidHom.coe_comp, Function.comp_apply, map_mul, map_zpow, FreeGroup.lift.of, hneq,
    ↓reduceIte, LinearEquiv.automorphismGroup.toLinearMapMonoidHom_apply,
    LinearEquiv.coe_toLinearMap_mul, Module.End.mul_apply, LinearEquiv.coe_coe, nonbasis_fixes hy,
    LinearMap.coe_mk, AddHom.coe_mk, T₁_zpow_acts, nonbasis_fixes hx, Prod.mk.injEq,
    Int.cast_eq_zero, and_true] at h
  exact h

lemma cancel_lemma' {a b:SM} {x y:N} {n:ℤ} (hb: b ≠ a) (hx : a ∉ basis_elements x) (hy : a ∉ basis_elements y) (heq: (e b) * ((e a)⁻¹ * ((e 0)^n * ((e a) * x))) = (e 0)^n * ((e b) * y)) : n = 0 := by
  have heq' : (e 0)^n * ((e a) * x) = (e a) * (e b)⁻¹ * ((e 0)^n * ((e b) * y)) := by
    rw [← heq]
    group
  apply_fun (fun x ↦ repr a x (1,0)) at heq'
  have hneq : 0 ≠ a := by
    contrapose! hx
    rw [←hx]
    exact zero_mem_basis_elements x
  simp only [MonoidHom.coe_comp, Function.comp_apply, map_mul, map_zpow, FreeGroup.lift.of, hneq,
    ↓reduceIte, LinearEquiv.automorphismGroup.toLinearMapMonoidHom_apply,
    LinearEquiv.coe_toLinearMap_mul, Module.End.mul_apply, LinearEquiv.coe_coe, nonbasis_fixes hx,
    LinearMap.coe_mk, AddHom.coe_mk, T₁_zpow_acts, map_inv, hb, LinearEquiv.inv_eq_symm,
    nonbasis_fixes hy, add_zero, T₁_zpow_fixes, LinearEquiv.coe_symm_mk, sub_zero, Prod.mk.injEq,
    Int.cast_eq_zero, and_true] at heq'
  exact heq'

end Eq1729
