import Mathlib.Algebra.DirectSum.Basic
import Mathlib.GroupTheory.FreeGroup.Basic
import Mathlib.Data.ZMod.Defs
import Mathlib.Data.Countable.Defs
import Mathlib.Data.DFinsupp.Encodable

import equational_theories.ForMathlib.GroupTheory.FreeGroup.ReducedWords
import equational_theories.Equations.All
import equational_theories.ManuallyProved.Equation1729.ExtensionTheorem

/- Constructs the small magma SM, basic properties of the additional set N, and sets out the axioms these objects need to satisfy -/

namespace Eq1729

/- SM is the abelian group generated by countably many generators E n of order 4 -/

abbrev SM := DirectSum ℕ (fun _ ↦ ZMod 4)

open AddToMagma -- makes SM a magma automatically

instance SM_countable : Countable SM := by
  convert instCountableDFinsupp
  . infer_instance
  infer_instance

abbrev E (n:ℕ) : SM := (DirectSum.of (fun _ ↦ ZMod 4) n) 1

@[simp]
lemma SM_op_eq_add (a b : SM) : a ◇ b = a + b := rfl

/- The squaring map on SM -/
def S (a : SM) := a ◇ a

@[simp]
lemma S_zero : S 0 = 0 := rfl

@[simp]
lemma SM_square_square_eq_zero (a : SM) : S (S a) = 0 := by
  simp only [S, SM_op_eq_add]
-- when we update Mathlib, one can switch to DirectSum.ext_component, or use the new version of DirectSum.ext
  apply DirectSum.ext ℤ
  intro i
  simp only [map_add, map_zero]
  abel_nf
  exact ZModModule.char_nsmul_eq_zero 4 _

lemma SM_square_eq_double (a : SM) : S a = a + a := rfl

lemma SM_obeys_1729 : Equation1729 SM := by
  intro x y
  simp only [SM_op_eq_add]
  abel_nf
-- when we update Mathlib, one can switch to DirectSum.ext_component, or use the new version of DirectSum.ext
  apply DirectSum.ext ℤ
  intro i
  simp only [map_add, map_smul, zsmul_eq_mul, Int.cast_ofNat, self_eq_add_left]
  apply zero_mul

def L (a:SM) : SM ≃ SM := {
  toFun := fun x ↦ x + a
  invFun := fun x ↦ x - a
  left_inv := leftInverse_sub_add_left a
  right_inv := by
    intro x
    simp only [sub_add_cancel]
}

def R (a:SM) : SM ≃ SM := L a

/- N is the free group generated by e_a for each a in SM -/

abbrev N := FreeGroup SM

instance N_countable : Countable N := Quotient.countable

abbrev e (a:SM) := FreeGroup.of a

def adjacent (x y : N) := ∃ a, x = (e a) * y ∨ y = (e a) * x

/-- Impose an order on N: x ≤ y if x is a right subword of y  (or equivalently, x is on the unique
simple path from 1 to y).  The spelling may not be optimal. -/
instance N_LE : LE N where
  le x y := x.toWord <:+ y.toWord

theorem le_def (x y : N) : (x ≤ y) = (x.toWord <:+ y.toWord) := rfl

instance N_order : PartialOrder N where
  le := N_LE.le
  le_refl _ := List.suffix_rfl
  le_trans _ _ _ := List.IsSuffix.trans
  le_antisymm x y hxy hyx := FreeGroup.toWord_injective <|
    List.IsSuffix.eq_of_length_le hxy (List.IsSuffix.length_le hyx)

instance : LocallyFiniteOrderBot N := LocallyFiniteOrderBot.ofIic
  (finsetIic := fun x => (List.map (FreeGroup.mk) x.toWord.tails).toFinset)
  (mem_Iic := fun a x => by
    simp only [List.mem_toFinset, List.mem_map, List.mem_tails, le_def]
    constructor
    · rintro ⟨a, h, eq⟩
      rw [← eq, FreeGroup.toWord_mk, FreeGroup.Red.reduced_iff_eq_reduce.mp]
      · exact h
      · exact FreeGroup.Red.reduced_infix (FreeGroup.reduced_toWord) h.isInfix
    · intro h
      use x.toWord
      simp [h, FreeGroup.mk_toWord])

/-- the parent of x is defined to be the unique element adjacent to x whose reduced word is shorter, with the junk convention that the parent of the identity is itself -/
def parent (x : N) : N := FreeGroup.mk x.toWord.tail

theorem parent_toWord (x : N) : (parent x).toWord = x.toWord.tail := by
  rw [parent, FreeGroup.toWord_mk, FreeGroup.Red.reduced_iff_eq_reduce.mp]
  exact FreeGroup.Red.reduced_infix (FreeGroup.reduced_toWord) (List.tail_suffix _).isInfix

theorem parent_le (x : N) : parent x ≤ x := by
  rw [le_def, parent_toWord]
  exact List.tail_suffix _

theorem lt_iff_le_parent {x y : N} (h : y ≠ 1) : x < y ↔ x ≤ parent y := by
  rw [lt_iff_le_and_ne, le_def, le_def, parent_toWord]
  cases h' : y.toWord
  case nil =>
    simp only [List.suffix_nil, FreeGroup.toWord_eq_nil_iff, ne_eq, List.tail_nil,
    and_iff_left_iff_imp]
    intro eq1 eq2
    exact h (eq2 ▸ eq1)
  case cons head tail =>
    simp only [List.tail_cons, List.suffix_cons_iff]
    constructor
    · rintro ⟨(eq | h'), ineq⟩
      · exfalso
        apply ineq
        apply FreeGroup.toWord_injective
        rw [eq, h']
      · assumption
    · intro h''
      constructor
      · right
        exact h''
      · intro eq'
        rw [eq', h'] at h''
        simpa using h''.length_le

instance : OrderBot N where
  bot := 1
  bot_le x := by simp [le_def]

theorem bot_eq_one : (⊥ : N) = 1 := rfl

instance : PredOrder N where
  pred := parent
  pred_le := parent_le
  min_of_le_pred hap := by
    rw [isMin_iff_eq_bot]
    rw [le_def, parent_toWord] at hap
    have := hap.length_le
    simp only [List.length_tail] at this
    rw [bot_eq_one, ← FreeGroup.toWord_eq_nil_iff, ← List.length_eq_zero]
    omega
  le_pred_of_lt {a} {b} hab := (lt_iff_le_parent hab.ne_bot).mp hab

theorem parent_adjacent (x : N) (h : x ≠ 1) : adjacent x (parent x) := by
  cases h' : x.toWord
  case nil =>
    simp only [FreeGroup.toWord_eq_nil_iff] at h'
    exact (h h').elim
  case cons head tail =>
    have eq : x = FreeGroup.mk [head] * parent x := by
      rw [← FreeGroup.mk_toWord (x := parent x), parent_toWord, h', ← FreeGroup.mk_toWord (x := x),
      h']
      rfl
    nth_rw 1 [eq]
    rcases head with ⟨a,⟨⟩⟩
    · use a
      right
      have eq_inv : FreeGroup.mk [(a, false)] = (e a)⁻¹ := by
        simp only [e, FreeGroup.of, FreeGroup.inv_mk]
        rfl
      simp [eq_inv]
    · use a
      left
      rfl

theorem adjacent_comm (x y : N) : adjacent x y ↔ adjacent y x := exists_congr (by tauto)

theorem parent_of_adjacent (x y : N) : adjacent x y → x = parent y ∨ y = parent x := by
  unfold adjacent
  rintro ⟨a, h⟩
  wlog l : x = e a * y generalizing x y
  · cases h
    · tauto
    case intro.inr.inr h => exact or_comm.mp (this y x (.inl h) h)
  cases h : y.toWord
  case nil =>
    right
    simp only [FreeGroup.toWord_eq_nil_iff] at h
    rw [l,h]
    simp only [parent, mul_one, FreeGroup.toWord_of, List.tail_cons]
    rfl
  case cons head tail =>
    by_cases eq : head = ⟨a, false⟩
    · left
      have eq' : y = FreeGroup.mk [head] * parent y := by
        rw [← FreeGroup.mk_toWord (x := parent y), parent_toWord, h, ← FreeGroup.mk_toWord (x := y),
        h]
        rfl
      rw [l]
      nth_rw 1 [eq']
      have eq_inv : FreeGroup.mk [head] = (e a)⁻¹ := by
        simp only [eq, e, FreeGroup.of, FreeGroup.inv_mk]
        rfl
      simp [eq_inv]
    · right
      have eq' : x.toWord = (a, true) :: y.toWord := by
        rw [l, FreeGroup.toWord_mul, FreeGroup.Red.reduced_iff_eq_reduce.mp]
        · rfl
        · rw [h]
          apply FreeGroup.Red.reduced_cons.mpr
          rw [← h]
          simp only [FreeGroup.reduced_toWord, and_true]
          cases head
          simp only [Bool.not_true, Bool.false_eq, not_and, Bool.not_eq_false]
          intro eq'
          simpa [eq'] using eq
      apply FreeGroup.toWord_injective
      simp [parent_toWord, eq']



/- Right-multiplication by an element of SM on N is defined via the group action. -/

def R' (a:SM) : N ≃ N := {
  toFun := fun x ↦ x * (e a)
  invFun := fun x ↦ x * (e a)⁻¹
  left_inv := by
    intro x
    simp only [mul_inv_cancel_right]
  right_inv := by
    intro x
    simp only [inv_mul_cancel_right]
}

lemma R'_axiom_iia (a b : SM) (y:N) (h: a ≠ b): R' a y ≠ R' b y := by
  contrapose! h
  simp only [R', Equiv.coe_fn_mk, mul_right_inj] at h
  exact FreeGroup.of_injective h

lemma R'_axiom_iib (a : SM) (y:N) : R' a y ≠ y := by
  by_contra! h
  simp only [R', Equiv.coe_fn_mk, mul_right_eq_self, FreeGroup.of_ne_one] at h

/- Now we rewrite the axioms using a single transformation L₀' instead of many transformations L' -/

/- Not sure if this is the best spelling for this axiom -/
def axiom_i' (L₀' : N → N) : Prop := L₀' ∘ L₀' = (R' 0).symm

lemma L₀'_R'0_L₀'_eq_id {L₀' : N → N} (h: axiom_i' L₀') : L₀' ∘ R' 0 ∘ L₀' = id := by
  unfold axiom_i' at h
  calc
    _ = L₀' ∘ R' 0 ∘ L₀' ∘ ((L₀' ∘ L₀') ∘ R' 0) := by aesop
    _ = (L₀' ∘ (R' 0 ∘ (L₀' ∘ L₀')) ∘ L₀') ∘ R' 0 := rfl
    _ = _ := by simp only [h, Equiv.self_comp_symm, CompTriple.comp_eq, Equiv.symm_comp_self]

def L' {L₀' : N → N} (h: axiom_i' L₀') (a:SM) : N ≃ N := {
  toFun := (R' a).symm ∘ L₀' ∘  R' (S a)
  invFun := (R' (S a)).symm ∘ L₀' ∘ (R' 0) ∘  (R' a)
  left_inv := by
    rw [Function.leftInverse_iff_comp]
    calc
      _ = (R' (S a)).symm ∘ L₀' ∘ R' 0 ∘ (R' a ∘ (R' a).symm) ∘ L₀' ∘ R' (S a) := rfl
      _ = (R' (S a)).symm ∘ (L₀' ∘ R' 0 ∘ L₀') ∘ R' (S a) := by aesop
      _ = _ := by simp only [L₀'_R'0_L₀'_eq_id h, CompTriple.comp_eq, Equiv.symm_comp_self]
  right_inv := by
    unfold axiom_i' at h
    rw [Function.rightInverse_iff_comp]
    calc
      _ = (R' a).symm ∘ ((L₀' ∘ (R' (S a) ∘ (R' (S a)).symm) ∘ L₀') ∘ R' 0) ∘ R' a := rfl
      _ = _ := by simp only [Equiv.self_comp_symm, CompTriple.comp_eq, h, Equiv.symm_comp_self]
}

lemma L'_0_eq_L₀' {L₀' : N → N} (h: axiom_i' L₀') : L' h 0 = L₀' := by
  unfold L'
  unfold axiom_i' at h
  simp only [← h, SM_square_eq_double, add_zero, Equiv.coe_fn_mk]
  rw [Function.comp_assoc, <- Function.comp_assoc _ _ (R' 0), h]
  simp only [Equiv.symm_comp_self, CompTriple.comp_eq]

abbrev M := SM ⊕ N

variable (f g h : ℕ → ℕ)

example : ℕ := f $ g $ h 0

abbrev axiom_iii' (S': N → SM) (L₀' : N → N)  := ∀ (a : SM) (x y : N), R' a x = y → ((R' (S' y)).symm $ L₀' $ R' (S (S' y)) $ (R' (a - S' x)).symm $ L₀' $ R' (S (a - S' x)) y) = x

abbrev axiom_iv' (S': N → SM) (L₀' : N → N) := ∀ x : N, ((R' (S' x)).symm $ L₀' $ R' (S (S' x)) $ (R' (S' x)).symm $ L₀' $ R' (S (S' x)) $ x) = x

abbrev axiom_v (S': N → SM) (op: N → N → M) := ∀ x : N, op x x = Sum.inl (S' x)

abbrev axiom_vi' (S': N → SM) (op: N → N → M) := ∀ (y : N) (a : SM), op (R' a y) y = Sum.inl (a - S' y)

abbrev axiom_vii' (S': N → SM) (L₀' : N → N) (op: N → N → M) := ∀ x y : N, x ≠ y → (∀ a : SM, x ≠ R' a y) → ∃ z : N, op x y = Sum.inr z ∧ op z x = Sum.inr ((R' (S (S' x))).symm $ L₀' $ R' 0 $ R' (S' x) $ y)

lemma reduce_to_new_axioms {S': N → SM} {L₀' : N → N} {op: N → N → M} (h_i': axiom_i' L₀') (h_iii': axiom_iii' S' L₀') (h_iv': axiom_iv' S' L₀') (h_v: axiom_v S' op) (h_vi': axiom_vi' S' op) (h_vii': axiom_vii' S' L₀' op) : ∃ (G: Type) (_: Magma G), Equation1729 G ∧ ¬ Equation817 G := by
  suffices : ExtOpsWithProps SM N
  . exact ⟨ M, extMagmaInst this, ExtMagma_sat_eq1729 this, ExtMagma_unsat_eq817 this ⟩
  exact
   {
    S := S
    L := fun x ↦ (fun y ↦ x ◇ y)
    R := fun x ↦ (fun y ↦ y ◇ x)
    S' := S'
    L' := (fun a ↦ L' h_i' a)
    R' := (fun a ↦ R' a)
    rest_map := op
    squaring_prop_SM := by intros; rfl
    left_map_SM := by intros; rfl
    right_map_SM := by intros; rfl
    sqN_extends_sqM := by intro _; aesop -- this is a tautology
    L_inv := by
      intro a
      exact {
        inv := fun y ↦ y - a
        inv_left := by
          ext y
          simp only [SM_op_eq_add, Function.comp_apply, add_sub_cancel_left, id_eq]
        inv_right := by
          ext y
          simp only [SM_op_eq_add, Function.comp_apply, add_sub_cancel, id_eq]
        bij := sorry -- redundant given the other data
      }
    L'_inv := by
      intro a
      exact {
        inv := (L' h_i' a).symm
        inv_left := Equiv.symm_comp_self _
        inv_right := Equiv.self_comp_symm _
        bij := sorry -- redundant given the other data
      }
    R_inv := by
      intro a
      exact {
        inv := fun y ↦ y - a
        inv_left := by
          ext y
          simp only [SM_op_eq_add, Function.comp_apply, add_sub_cancel_right, id_eq]
        inv_right := by
          ext y
          simp only [SM_op_eq_add, Function.comp_apply, sub_add_cancel, id_eq]
        bij := sorry -- redundant given the other data
      }
    R'_inv := by
      intro a
      exact {
        inv := (R' a).symm
        inv_left := Equiv.symm_comp_self _
        inv_right := Equiv.self_comp_symm _
        bij := sorry -- redundant given the other data
      }
    SM_sat_1729 := SM_obeys_1729
    axiom_1 := by
      intro a
      simp only [L', SM_square_square_eq_zero, Equiv.coe_fn_mk]
      calc
        _ = (R' (S a)).symm ∘ (L₀' ∘ (R' 0) ∘ ((R' a) ∘ (R' a).symm) ∘ L₀') ∘ (R' (S a))  := rfl
        _ = _ := by simp [L₀'_R'0_L₀'_eq_id h_i']
    axiom_21 := by
      intro a b y h
      simp only [ne_eq, R'_axiom_iia a b y h, not_false_eq_true]
    axiom_22 := by
      intro a x
      simp only [ne_eq, R'_axiom_iib a x, not_false_eq_true]
    axiom_3 := by
      intro x y a h
      simp only [L', Equiv.coe_fn_mk, Function.comp_apply, h_iii' a x y h]
    axiom_4 := by
      intro x
      simp only [L', Equiv.coe_fn_mk, Function.comp_apply, h_iv' x]
    axiom_5 := by
      intro x
      simp [L', h_v x]
    axiom_6 := by
      intro y a
      simp [L', h_vi' y a]
   }

end Eq1729
