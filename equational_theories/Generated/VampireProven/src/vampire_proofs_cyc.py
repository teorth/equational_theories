#!/usr/bin/env python3

import subprocess, json, random, pickle
from tqdm import tqdm
import time
from generate_eqs_list import *
from find_powerful_theorems import *
import re
from collections import defaultdict

random.seed(17)

# with open('conjectures.json') as fs:
#   problems = json.load(fs)

# problems = problems['implications']

# with open('todo.csv') as fs:
#   problems = [{'lhs': 'Equation' + x.split(',')[0], 'rhs': 'Equation' + x.strip().split(',')[1]}
#               for x in fs]

# print(len(problems))

BVARS = 'XYZWUV'

def format_expr2(expr):
    if isinstance(expr, int):
        return BVARS[expr]
    return f'mul({format_expr2(expr[0])}, {format_expr2(expr[1])})'

def format_eq(eq):
  v = ''
  for i in BVARS[:count_vars(eq)]:
    v += f'! [{i}] : '
  return f'{v}{format_expr2(eq[0])} = {format_expr2(eq[1])}'


def encode_problem(problem):
  assumption, goal = eqs[problem[0]], eqs[problem[1]]
  return f'fof(lhs, axiom, {format_eq(assumption)}).\nfof(rhs, conjecture, {format_eq(goal)}).\n'

def natural_sort(l):
    convert = lambda text: int(text) if text.isdigit() else text.lower()
    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]
    return sorted(l, key=alphanum_key)

def leanifyS(statement):
  statement = re.sub('mul', '', statement)
  statement = re.sub(',', ' ◇ ', statement)
  statement = re.sub('!=', '≠', statement)
  variables = natural_sort({x for x in re.findall('\w+', statement) if 'sK' not in x})
  variables = f'({" ".join(variables)} : G) ' if variables else ''
  return f'{variables}: {statement}'

def leanifyP(proof):
  sr = re.match(r'superposition (\d+),(\d+)', proof)
  if sr is not None:
    return f'superpose eq{sr[2]} eq{sr[1]}'
  sr = re.match(r'backward demodulation (\d+),(\d+)', proof)
  if sr is not None:
    return f'superpose eq{sr[2]} eq{sr[1]}'
  sr = re.match(r'forward demodulation (\d+),(\d+)', proof)
  if sr is not None:
    return f'superpose eq{sr[2]} eq{sr[1]}'
  raise NotImplementedError(proof)

def leanify(proof, problem):
  assumption, goal = eqs[problem[0]], eqs[problem[1]]
  output = f'@[equational_result]\ntheorem {problem["lhs"]}_implies_{problem["rhs"]} ' \
      f'(G : Type*) [Magma G] (h : {problem["lhs"]} G) : {problem["rhs"]} G := by\n'
  output += '  by_contra nh\n  simp only [not_forall] at nh\n'
  output += f'  obtain ⟨{", ".join("sK" + str(i) for i in range(count_vars(goal)))}, nh⟩ := nh\n'
  for eqnum, statement, proof in re.findall(r'(\d+)\. ([^[]+) \[([^\]]+)\]', proof):
    # print(eqnum, statement, proof)
    if proof.startswith('X') or proof.startswith('skolemisation'):
      continue
    if proof.startswith('cnf transformation'):
      if '!=' in statement:
        output += f'  have eq{eqnum} {leanifyS(statement)} := mod_symm nh\n'
      else:
        output += f'  have eq{eqnum} {leanifyS(statement)} := mod_symm (h ..)\n'
      continue
    if statement == '$false':
      sr = re.match(r'subsumption resolution (\d+),(\d+)', proof)
      if sr is not None:
        output += f'  subsumption eq{sr[1]} eq{sr[2]}\n\n'
        continue
      sr = re.match(r'trivial inequality removal (\d+)', proof)
      if sr is not None:
        output += f'  subsumption eq{sr[1]} rfl\n\n'
        continue
      sr = re.match(r'equality resolution (\d+)', proof)
      if sr is not None:
        output += f'  subsumption eq{sr[1]} rfl\n\n'
        continue
      print(output)
      raise NotImplementedError(proof)
    else:
      output += f'  have eq{eqnum} {leanifyS(statement)} := {leanifyP(proof)} -- {proof}\n'
  return output

def get_problem(matrix, bad):
  # ts = time.perf_counter()
  impls = find_most_useful_implication(matrix, -1)
  print('Returned', impls)
  # print('Time to get implications', time.perf_counter() - ts)
  # if not impls:
  #   raise KeyboardInterrupt('No remaining pairs')
  done = True
  for (i, j), v in impls:
    if (i ,j) not in bad:
      done = False
      print('value', v)
      yield i, j
  if done:
    raise KeyboardInterrupt('No remaining pairs')


if __name__ == '__main__':
  dpind = 14
  proofs = open(f'equational_theories/Generated/VampireProven/Proofs{dpind}.lean', 'w')
  print('''import equational_theories.Superposition
  import equational_theories.Equations.All
  import Mathlib.Tactic.TypeStar
  import Mathlib.Tactic.ByContra
  ''', file=proofs)
  length = 0
  proof_list = open(f'equational_theories/Generated/VampireProven.lean', 'a')
  print(f'import equational_theories.Generated.VampireProven.Proofs{dpind}', file=proof_list)

  with open('cache.out', 'rb') as f: # generated by find powerful theorems
    matrix = np.load(f)

  try:
    with open('giveup.pkl', 'rb') as f:
      givenupon = pickle.load(f)
  except FileNotFoundError:
    givenupon = set()

  cyc = 0

  try:
    progress = tqdm()
    while True:
      for problem in get_problem(matrix, givenupon):
        problem = (int(problem[0]), int(problem[1]))
        progress.update()
        pr = encode_problem(problem)
        tqdm.write(f'Considering {problem}')

        try:
          out = subprocess.check_output(['~/Downloads/vampire', '--mode', 'casc_sat', '--cores', '0',
                                        '/proc/self/fd/0', '-t', '0.2'], input=pr.encode()).decode()
        except subprocess.CalledProcessError as e:
          assert e.returncode == 1
          try:
            out = subprocess.check_output(['~/Downloads/vampire', '--mode', 'casc', '--cores', '0',
                                          '/proc/self/fd/0', '-t', '0.2'], input=pr.encode()).decode()
          except subprocess.CalledProcessError as e:
            assert e.returncode == 1
            tqdm.write(f'Could\'nt handle {problem}')
            givenupon.add(problem)
            conj = open('unproven.txt', 'a')
            print(problem, file=conj)
            conj.close()
            continue
        if 'Termination reason: Satisfiable' in out:
          matrix[problem[0], problem[1]] = 2
          tqdm.write(f'Disproved {problem}')
          conj = open('conjectures.txt', 'a')
          print(problem, file=conj)
          conj.close()
          cyc += 1
          if cyc % 500 == 0:
            break
          else:
            continue
        tqdm.write(f'Proved {problem}!!')
        matrix[problem[0], problem[1]] = 1
        lean_proof = leanify(out, problem)
        print(lean_proof, file=proofs)
        break


  except KeyboardInterrupt:
    with open('giveup.pkl', 'wb') as f:
      pickle.dump(givenupon, f)
    with open('cache.out', 'wb') as f: # generated by find powerful theorems
      np.save(f, matrix)
    progress.close()
