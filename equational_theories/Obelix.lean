import Mathlib.Algebra.Order.Ring.Nat
import Mathlib.Data.DFinsupp.Notation
import Mathlib.Data.ZMod.Defs
import Mathlib.Logic.Denumerable
import Mathlib.GroupTheory.FiniteAbelian
import Mathlib.Tactic

import equational_theories.FactsSyntax
import equational_theories.EquationalResult
import equational_theories.Equations.Basic

-- The ``Obelix law''
-- equation 1491 := x = (y ◇ x) ◇ (y ◇ (y ◇ x))

namespace Obelix
noncomputable section

--The particular group that we'll work on: ℕ-indexed functions to ℤ with finite support.
--To ensure that this is computable (so that we can get the first few elements and verify
--that our non-Astericity), we use DFinsupp, the computable (and dependent) friend of Finsupp.
--The ℕ lets us easily get "fresh" generators to keep extending the function. Finite support means
--that the group is still countable, so we can denumerate every element and eventually add it
--to the domain. We could easily use ℚ or Fin p instead of ℤ if we wanted.
--Significant amounts of the construction -- even defining the invariants of the partial function --
--depend on this, so we use it explicitly instead of making PartialSolution depend on a group G.
abbrev A : Type := Π₀ _ : ℕ, ℤ

instance A_group : AddCommGroup A := inferInstance

@[ext]
structure PartialSolution where
  --A partial solution is a function f : A → A satisfying certain invariants, with finite domain Dom.
  Dom : Finset A
  f : A → A
  --f is injective on its domain.
  Inj : Dom.toSet.InjOn f
  --f maps the identity to itself
  Dom0 : 0 ∈ Dom
  Id : f 0 = 0
  --If x and f(x) are in the domain, so is f (f x) - f(x).
  Closed_sub : ∀ {a}, a ∈ Dom → f a ∈ Dom → f (f a) - f a ∈ Dom
  --For all x where it's defined, f( f(f(x)) - f(x) ) = x - f(x).
  Valid : ∀ {a}, a ∈ Dom → f a ∈ Dom → f (f (f a) - f a) = a - f a
  --If a and b are in the domain and f(a)-a = f(b)-b, then a=b.
  --Could also be stated as "[fun x ↦ f(x)-x] is injective where defined", hence the name here.
  SubInj : ∀ {a b}, a ∈ Dom → b ∈ Dom → a - f a = b - f b → a = b
  --The extendability criteria: if b is in the image of f as f(a) but not the domain, then
  -- (1) a-b must not be in the domain, and (2) a-b must not be in the range.
  ExtendDom : ∀ {a}, a ∈ Dom → f a ∉ Dom → a - f a ∉ Dom
  ExtendImg : ∀ {a}, a ∈ Dom → f a ∉ Dom → a - f a ∉ f '' Dom

namespace PartialSolution

/-- The image of the partial solution -/
def Im (f : PartialSolution) := f.Dom.image f.f

/-- f.ExtendImg, stated in terms of f.Im -/
theorem ExtendImg' (f : PartialSolution) : ∀ {a}, a ∈ f.Dom → f.f a ∉ f.Dom → a - f.f a ∉ f.Im := by
  intro a h₁ h₂
  convert f.ExtendImg h₁ h₂
  funext x
  simp only [Im, Finset.mem_image, Set.mem_image, Finset.mem_coe]

/-- The group Π₀ : ℕ → ℤ is not finitely generated. -/
theorem A_not_FG : ¬(AddGroup.FG A) :=
  have h : ¬(AddGroup.FG (Π₀ _ : ℕ, Fin 1064)) := fun _ ↦ DFinsupp.infinite_of_left.not_finite
    <| AddCommGroup.finite_of_fg_torsion (Π₀ _ : ℕ, Fin 1064) (fun _ ↦ by
    rw [isOfFinAddOrder_iff_nsmul_eq_zero]
    exact ⟨1064, by simp, by ext; simp [show (1064:Fin 1064) = 0 by rfl]⟩
  )
  let f : A →+ (Π₀ _ : ℕ, Fin 1064) := DFinsupp.mapRange.addMonoidHom fun _ ↦ Int.castAddHom _
  have : Function.Surjective f := Function.HasRightInverse.surjective
    ⟨DFinsupp.mapRange (fun _ x ↦ x) (by simp), fun _ ↦ by ext; simp [DFinsupp.mapRange, f]⟩
  fun _ ↦ h (AddGroup.fg_of_surjective this)

instance instADenumerable : Denumerable A :=
  Denumerable.ofEncodableOfInfinite A

--This instance lying around keeps on causing diamonds
attribute [-instance] instEncodableDFinsuppOfDecidableNeOfNat

/-- Get a fresh generator that's not generated by the values in the domain so far, the images
 so far, and a new value x. (If x isn't needed, we can just provide 0.) -/
@[irreducible]
def freshGenerator (f : PartialSolution) (x : A := 0) : A := by
  have : ∃ y, y ∉ AddSubgroup.closure (f.Dom ∪ f.Im ∪ {x} : Set A) := by
    by_contra h
    apply AddGroup.fg_iff.mpr.mt A_not_FG
    push_neg at h
    use (f.Dom ∪ f.Im ∪ {x} : Set A)
    simpa [AddSubgroup.eq_top_iff'] using h
  exact Classical.choose this

theorem freshGenerator_not_subgroup (f : PartialSolution) (x : A) :
    f.freshGenerator x ∉ AddSubgroup.closure (f.Dom ∪ f.Im ∪ {x}) := by
  rw [freshGenerator]
  exact Classical.choose_spec (freshGenerator.proof_1 f x )

section freshGenerator_lemmas

variable (f : PartialSolution) {x y : A} (a : A := 0)

theorem freshGenerator_not_dom : f.freshGenerator a ∉ f.Dom := by
  have := AddSubgroup.not_mem_of_not_mem_closure (f.freshGenerator_not_subgroup a)
  rw [Set.union_assoc] at this
  contrapose! this
  exact Set.mem_union_left _ this

lemma freshGenerator_not_img : f.freshGenerator a ∉ f.f '' f.Dom := by
  sorry

lemma freshGenerator_not_Im : f.freshGenerator a ∉ f.Im := by
  sorry

lemma fresh_ne_0 : f.freshGenerator a ≠ 0 := by
  sorry

lemma fresh_ne_1 : f.freshGenerator a ≠ a := by
  sorry

lemma fresh_ne_2 (h : x ∈ f.Dom) : f.f x ≠ f.freshGenerator a := by
  sorry

lemma fresh_ne_4 (h : x ∈ f.Dom) (h : y ∈ f.Dom) : f.f x + f.f y ≠ f.freshGenerator a := by
  sorry

lemma fresh_ne_5 (hx : x ∈ f.Dom) (hy : y ∈ f.Dom) : f.freshGenerator a ≠ y + f.f x := by
  sorry

lemma fresh_ne_6 (hx : x ∈ f.Dom) : a - f.freshGenerator a ≠ x - f.f x := by
  sorry

lemma fresh_ne_7 : a - f.freshGenerator a ∉ f.Dom := by
  sorry

lemma fresh_ne_8 : f.freshGenerator a ≠ a - f.freshGenerator a := by
  sorry

lemma fresh_ne_9 (h : x ∈ f.Dom) : f.f x ≠ a - f.freshGenerator a := by
  sorry

lemma fresh_ne_10 (h : x ∈ f.Dom) : f.freshGenerator a ≠ x - f.f x:= by
  sorry

end freshGenerator_lemmas

/-- Extend a partial solution at an element x in its domain, so that x obeys the functional equation. -/
def extend (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) : PartialSolution :=
  if hb : f.f x ∈ f.Dom then f else
    let b := f.f x;
    let c := f.freshGenerator;
    have hb : b ∉ f.Dom := hb
    have hb₀ : b ≠ 0 := fun h ↦ hb (h ▸ f.Dom0)
    have hc₀ : c ≠ 0 := f.fresh_ne_0
    have hbc : b ≠ c := f.fresh_ne_2 _ hx
    have h2bc : b + b ≠ c := f.fresh_ne_4 _ hx hx
    have hcbb : c - b ≠ b := by
      intro h
      nth_rewrite 1 [←h] at h2bc
      simp at h2bc
    have hcbcb : c ≠ b - (c - b) := by
      sorry
    have hzcb : ∀ z ∈ f.Dom, z ≠ c - b := by
      sorry
  {
    Dom := insert b <| insert (c - b) f.Dom
    f := fun x ↦
      if x = b then c
      else if x = c - b then b - x
      else f.f x
    Inj := by
      intro x hx y hy
      simp at hx hy
      rcases hx with (hx|hx|hx) <;>
      rcases hy with (hy|hy|hy)
      all_goals try simp only [hx, hy, ↓reduceIte, imp_self, hcbb]
      all_goals try (have hyb : y ≠ b := fun h ↦ hb (h ▸ hy); simp [hyb])
      all_goals try (have hxb : x ≠ b := fun h ↦ hb (h ▸ hx); simp [hxb])
      all_goals try (have hycb := hzcb y hy; simp [hycb])
      all_goals try (have hxcb := hzcb x hx; simp [hxcb])
      all_goals try clear x hx
      all_goals try clear y hy
      · exact fun h ↦ (hcbcb h).elim
      · sorry
      · exact hcbcb.symm
      · sorry
      · intro h2
        apply f.freshGenerator_not_img
        use x, hx
      · sorry
      · exact f.Inj hx hy
    Dom0 := by simp [f.Dom0]
    Id := by simpa [hb₀.symm, Ne.symm (sub_ne_zero_of_ne hbc.symm)] using f.Id
    Closed_sub := by sorry
    Valid := by sorry
    SubInj := by sorry
    ExtendDom := by
      intro y hy
      simp at hy
      rcases hy with (hy|hy|hy)
      · simp [hy, hc₀]
        intro h1 h2 h3
        constructor
        · sorry
        · sorry
      · simp [hy, hc₀, hcbb]
        intro h1 h2 h3
        constructor
        · sorry
        · constructor
          · sorry
          · sorry
      · have hyb : y ≠ b := fun h ↦ hb (h ▸ hy)
        simp [hyb, hzcb y hy]
        intro h1 h2 h3
        constructor
        · sorry
        · constructor
          · sorry
          · sorry
    ExtendImg := by sorry
  }

/-- Extend preserves the function on its support -/
theorem extend_mono (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    ∀ y ∈ f.Dom, y ∈ (f.extend hx).Dom ∧ (f.extend hx).f y = f.f y := by
  intro y hy
  by_cases hf : f.f x ∈ f.Dom
  · simp [extend, hf, hy]
  · simp [extend, hf]
    by_cases hyf : y = f.f x
    · exact (hf (hyf ▸ hy)).elim
    · have : y ≠ f.freshGenerator - f.f x := (f.fresh_ne_5 _ hx hy).symm ∘ add_eq_of_eq_sub
      simp [hyf, hy, this]

theorem extend_mono_dom (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    ∀ y ∈ f.Dom, y ∈ (f.extend hx).Dom :=
  fun y hy ↦ ((f.extend_mono hx) y hy).1

theorem extend_mono_f (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    ∀ y ∈ f.Dom, (f.extend hx).f y = f.f y :=
  fun y hy ↦ ((f.extend_mono hx) y hy).2

/-- Extend makes sure that f x is in the domain -/
theorem extend_dom (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    (f.extend hx).f x ∈ (f.extend hx).Dom := by
  by_cases hf : f.f x ∈ f.Dom
  · simp [extend, hf]
  · simp [extend, hf]
    by_cases hxf : x = f.f x
    · exact (hf (hxf ▸ hx)).elim
    · have : x ≠ f.freshGenerator - f.f x := (f.fresh_ne_5 _ hx hx).symm ∘ add_eq_of_eq_sub
      simp [hxf, this]

/-- Extend makes sure that x obeys the functional equation -/
theorem extend_valid (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    let f' := (f.extend hx).f; f' (f' (f' x) - f' x) = x - f' x :=
  (f.extend hx).Valid (f.extend_mono_dom hx x hx) (f.extend_dom hx)

/-- Extend a partial solution with an element *not* in its domain. -/
def add (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im)
    (hxs : ¬∃ w, w ∈ f.Dom ∧ w - f.f w = x)
    : PartialSolution :=
  let b := f.freshGenerator x;
  have hx₀ : x ≠ 0 := fun h ↦ hx (h ▸ f.Dom0 : x ∈ f.Dom)
  have hb₀ : b ≠ 0 := f.fresh_ne_0 x
  have hbx : b ≠ x := f.fresh_ne_1 x
  have hbdom : b ∉ f.Dom := f.freshGenerator_not_dom x
  have hbimg : b ∉ f.Im := f.freshGenerator_not_Im x
  have hb2 : ∀ z, z ∈ f.Dom → x - b ≠ z - f.f z := fun _ ↦ f.fresh_ne_6 x
  have hxb : x - b ∉ f.Dom := f.fresh_ne_7 x
  have hbxb : b ≠ x - b := f.fresh_ne_8 x
  have hb3 : ∀ z, z ∈ f.Dom → f.f z ≠ x - b:= fun _ ↦ f.fresh_ne_9 x
  have hb4 : ∀ z, z ∈ f.Dom → b ≠ z - f.f z := fun _ ↦ f.fresh_ne_10 x
  {
    Dom := insert x f.Dom
    f := fun y ↦ if x = y then b else f.f y
    Inj := by
      intro y hy z hz
      simp only [Finset.coe_insert, Set.mem_insert_iff, Finset.mem_coe] at hy hz
      rcases hy with rfl|hy <;> rcases hz with rfl|hz
      · simp
      · have hyz : y ≠ z := fun h ↦ hx (h ▸ hz)
        simp only [hyz, ↓reduceIte, imp_false, ← ne_eq]
        symm
        exact fun h ↦ hbimg (by simp [Im]; use z)
      · have hyz : y ≠ z := fun h ↦ hx (h ▸ hy)
        simp only [hyz.symm, hyz, ↓reduceIte, imp_false, ← ne_eq]
        exact fun h ↦ hbimg (by simp [Im]; use y)
      · have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
        have hxz : x ≠ z := fun h ↦ hx (h ▸ hz)
        simp only [hxy, hxz, ↓reduceIte]
        exact f.Inj hy hz
    Dom0 := by simp [f.Dom0]
    Id := by simp [hx₀, f.Id]
    Closed_sub := by
      intro y hy
      rw [Finset.mem_insert] at hy
      rcases hy with rfl|hy
      · simp [hbx, hbdom]
      · have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
        have hxy2 : f.f y ≠ x := fun h ↦ hxi (by simp [Im]; use y)
        simp only [hxy, hxy2, hxy2.symm, false_or, ↓reduceIte, Finset.mem_insert]
        exact fun h ↦ Or.inr (f.Closed_sub hy h)
    Valid := by
      intro y hy
      rw [Finset.mem_insert] at hy
      rcases hy with rfl|hy
      · simp [hbx, hbdom]
      · have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
        have hxy2 : f.f y ≠ x := fun h ↦ hxi (by simp [Im]; use y)
        simp only [hxy, hxy2, hxy2.symm, false_or, ↓reduceIte, Finset.mem_insert]
        intro hy2
        have hxy3 : x ≠ f.f (f.f y) - f.f y := fun h ↦ hx (h ▸ f.Closed_sub hy hy2)
        rw [if_neg hxy3]
        exact f.Valid hy hy2
    SubInj := by
      intro y z hy hz
      simp only [Finset.mem_insert, @eq_comm _ _ x] at hy hz
      rcases hy with rfl|hy <;> rcases hz with rfl|hz
      · simp
      · have hxz : x ≠ z := fun h ↦ hx (h ▸ hz)
        simp only [hxz, ↓reduceIte, imp_false, ← ne_eq]
        exact hb2 z hz
      · have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
        simp only [hxy, ↓reduceIte, imp_false, ← ne_eq]
        exact fun h ↦ ((hb2 y hy).symm h).elim
      · have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
        have hxz : x ≠ z := fun h ↦ hx (h ▸ hz)
        simp only [hxy, hxz, ↓reduceIte, imp_false, ← ne_eq]
        exact f.SubInj hy hz
    ExtendDom := by
      intro y hy
      simp only [Finset.mem_insert, @eq_comm _ _ x] at hy
      rcases hy with rfl|hy
      · simp [hb₀, hxb]
      · have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
        simp only [hxy, ↓reduceIte, Finset.mem_insert, not_or, and_imp]
        intro _ h₂
        have hxy2 : y - f.f y ≠ x := by
          simp only [not_exists, not_and] at hxs
          exact hxs y hy
        simpa [hxy2, not_false_eq_true, true_and] using f.ExtendDom hy h₂
    ExtendImg := by
      intro y hy
      simp only [Finset.mem_insert, @eq_comm _ _ x] at hy
      rcases hy with rfl|hy
      · simp [hbdom, hbxb, hbx]
        intro z hz
        have hxz : x ≠ z := fun h ↦ hx (h ▸ hz)
        simp [hxz, hb3 z hz]
      · have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
        simp [hxy, hb4 y hy]
        intro _ h₂ z hz
        have hxz : x ≠ z := fun h ↦ hx (h ▸ hz)
        have := f.ExtendImg hy h₂
        simp [hxz] at this ⊢
        exact this z hz
  }

/-- Add preserves the function on its domain -/
theorem add_mono (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im)
    (hxs : ¬∃ w, w ∈ f.Dom ∧ w - f.f w = x) :
    ∀ y ∈ f.Dom, y ∈ (f.add hx hxi hxs).Dom ∧ (f.add hx hxi hxs).f y = f.f y := by
  intro y hy
  have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
  simp [add, hy, hxy]

theorem add_mono_dom (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im)
    (hxs : ¬∃ w, w ∈ f.Dom ∧ w - f.f w = x) :
    ∀ y ∈ f.Dom, y ∈ (f.add hx hxi hxs).Dom :=
  fun y hy ↦ (f.add_mono hx hxi hxs y hy).1

theorem add_mono_f (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im)
    (hxs : ¬∃ w, w ∈ f.Dom ∧ w - f.f w = x) :
    ∀ y ∈ f.Dom, (f.add hx hxi hxs).f y = f.f y :=
  fun y hy ↦ (f.add_mono hx hxi hxs y hy).2

/-- The added partial solution has the new element in the domain. -/
theorem add_dom (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im)
    (hxs : ¬∃ w, w ∈ f.Dom ∧ w - f.f w = x) :
    x ∈ (f.add hx hxi hxs).Dom := by
  simp [add]

def closeImg (f : PartialSolution) (x : A) (hxi : x ∈ f.Im): PartialSolution :=
  --If x is in the image but not the domain, find the unique y such that f(y) = x
    let y : A := Finset.choose (f.f · = x) f.Dom (by
      obtain ⟨y,hy₁,hy₂⟩ := Finset.mem_image.mp hxi;
      use y
      simp [hy₁, hy₂]
      exact fun _ hz ↦ hy₂ ▸ (f.Inj hz hy₁)
    )
    have hy : y ∈ f.Dom := Finset.choose_mem _ _ _
    have hfy₂ : (f.extend hy).f y = x := (f.extend_mono_f _ y hy).trans
      (Finset.choose_spec (f.f · = x) _ _).2
    --And then `extend y` (so that x is in the domain), and finally `extend x`
    (f.extend hy).extend (hfy₂ ▸ f.extend_dom hy)

/-- Given f, (possibly) extend it to ensure that x is in the domain, image, and obeys the functional
  equation. This is done by possibly using `add` to include x, and then `extend`. -/
def close (f : PartialSolution) (x : A) : PartialSolution :=
  if hx : x ∈ f.Dom then
    --If x is in the domain, just make sure that it obeys the functional equation with `extend`.
    f.extend hx
  else if hxi : x ∈ f.Im then
    f.closeImg x hxi
  else if hxs : ∃ w, w ∈ f.Dom ∧ w - f.f w = x then
    --If x is in the image but not the domain, find the unique y such that f(y) = x
    let w : A := Finset.choose (fun w ↦ w - f.f w = x) f.Dom (by
      obtain ⟨y,hy₁,hy₂⟩ := hxs;
      use y
      simp [hy₁, hy₂]
      exact fun _ hz ↦ hy₂ ▸ (f.SubInj hz hy₁)
    )
    have hw : w ∈ f.Dom := Finset.choose_mem _ _ _
    have hw₂ := f.extend_mono_dom hw _ hw
    have hfw₂ : w - (f.extend hw).f w = x := (f.extend_mono_f _ w hw) ▸
      (Finset.choose_spec (fun w ↦ w - f.f w = x) _ _).2
    --And then `extend y` (so that x is in the domain), and finally `extend x`
    (f.extend hw).closeImg x (by
      simp [Im]
      use (f.extend hw).f ((f.extend hw).f w) - (f.extend hw).f w
      constructor
      · exact (f.extend hw).Closed_sub hw₂ (f.extend_dom hw)
      · exact hfw₂ ▸ (f.extend hw).Valid hw₂ (f.extend_dom hw)
    )
  else
    --Otherwise x is in neither the domain nor the image and we use `add`, `extend`.
    (f.add hx hxi hxs).extend (f.add_dom hx hxi hxs)

/-- The closed partial solution has the new element `x` in the domain. -/
theorem close_dom (f : PartialSolution) {x : A} :
    x ∈ (f.close x).Dom := by
  rw [close]
  split_ifs with h₁ h₂
  · apply extend_mono_dom
    exact h₁
  · rw [closeImg]
    apply extend_mono_dom
    exact closeImg.proof_4 f x h₂ _ (closeImg.proof_3 f x h₂ _)
  · rename_i h
    simp only [closeImg]
    apply extend_mono_dom
    let h₃ := close.proof_2 _ _ h
    let h₄ := close.proof_4 f x h _ (extend_mono_dom _ _ _ h₃) (close.proof_3 _ _ h h₃)
    exact closeImg.proof_4 _ _ h₄ _ (closeImg.proof_3 _ _ h₄ (closeImg.proof_2 _ _ h₄))
  · apply extend_mono_dom
    apply add_dom

/-- The closed partial solution has `f x` in the domain. -/
theorem close_f_dom (f : PartialSolution) {x : A} :
    (f.close x).f x ∈ (f.close x).Dom := by
  rw [close]
  split_ifs
  · apply extend_dom
  · rw [closeImg]
    apply extend_dom
  · simp only [closeImg]
    apply extend_dom
  · apply extend_dom

theorem close_mono (f : PartialSolution) (x : A) :
    ∀ y, y ∈ f.Dom → y ∈ (f.close x).Dom := by
  rw [close]
  split_ifs
  · apply extend_mono_dom
  · intro y hy
    rw [closeImg]
    apply extend_mono_dom
    apply extend_mono_dom _ _ _ hy
  · simp only [closeImg]
    intro y hy
    repeat apply extend_mono_dom
    exact hy
  · intro y hy
    apply extend_mono_dom
    exact add_mono_dom _ _ _ _ _ hy

theorem close_extend (f : PartialSolution) (x : A) :
    ∀ y, y ∈ f.Dom → (f.close x).f y = f.f y := by
  rw [close]
  split_ifs
  · apply extend_mono_f
  · intro y hy
    rw [closeImg, extend_mono_f]
    apply extend_mono_f _ _ _ hy
    exact extend_mono_dom _ _ _ hy
  · simp only [closeImg]
    intro y hy
    repeat rw [extend_mono_f _ _ _]
    all_goals repeat apply extend_mono_dom
    all_goals assumption
  · intro y hy
    rw [extend_mono_f]
    exact add_mono_f _ _ _ _ _ hy
    exact add_mono_dom _ _ _ _ _ hy

/-- Repeatedly extend f by the least element not in its domain, and the bifurcation tree that element
  generates. -/
def closureSeq (f : PartialSolution) : ℕ → PartialSolution
| 0 => f
| n+1 => (closureSeq f n).close (Denumerable.ofNat A n)

theorem mem_closureSeq (f : PartialSolution) (x : A) :
    x ∈ (f.closureSeq (Encodable.encode x + 1)).Dom := by
  rw [closureSeq.eq_def]
  simp only [Denumerable.ofNat_encode _]
  apply close_dom

theorem mem_f_closureSeq (f : PartialSolution) (x : A) :
    (f.closureSeq (Encodable.encode x + 1)).f x ∈ (f.closureSeq (Encodable.encode x + 1)).Dom := by
  rw [closureSeq.eq_def]
  simp only [Denumerable.ofNat_encode _]
  apply close_f_dom

theorem closureSeq_mono (f : PartialSolution) (n : ℕ) :
    ∀ x, x ∈ f.Dom → x ∈ (f.closureSeq n).Dom := by
  induction n
  · simp [closureSeq]
  next k ih =>
    rw [closureSeq]
    intro x hx
    apply (f.closureSeq k).close_mono _ _ (ih x hx)

theorem closureSeq_extends (f : PartialSolution) (n : ℕ) :
    ∀ x, x ∈ f.Dom → (f.closureSeq n).f x = f.f x := by
  induction n
  · simp [closureSeq]
  next k ih =>
    rw [closureSeq]
    intro x hx
    rw [(f.closureSeq k).close_extend _ x (f.closureSeq_mono _ _ hx)]
    exact ih x hx


theorem closureSeq_ascDom (f : PartialSolution) (n k : ℕ) :
    ∀ x, x ∈ (f.closureSeq n).Dom → x ∈ (f.closureSeq (n+k)).Dom := by
  induction k
  · simp [closureSeq]
  next k ih =>
    intro x hx
    rw [← add_assoc, closureSeq]
    exact (f.closureSeq _).close_mono _ _ (ih x hx)

theorem closureSeq_asc (f : PartialSolution) (n k : ℕ) :
    ∀ x, x ∈ (f.closureSeq n).Dom → (f.closureSeq (n+k)).f x = (f.closureSeq n).f x := by
  induction k
  · simp [closureSeq]
  next k ih =>
    intro x hx
    rw [← add_assoc, closureSeq]
    rw [(f.closureSeq _).close_extend _ x (f.closureSeq_ascDom _ _ _ hx)]
    exact ih x hx

/-- Make the linearizing function f from the closure. -/
def closureLinear (f : PartialSolution) : A → A :=
  fun a ↦ (f.closureSeq (Encodable.encode a + 1)).f a

theorem closureLinear_eq_closureSeq (f : PartialSolution) (n : ℕ) (a : A) (hn : a ∈ (closureSeq f n).Dom) :
    f.closureLinear a = (f.closureSeq n).f a := by
  simp only [closureLinear]
  rcases le_total n (Encodable.encode a + 1) with h | h
  · obtain ⟨k,hk⟩ := Nat.le.dest h
    rw [← hk]
    exact closureSeq_asc _ _ _ _ hn
  · obtain ⟨k,hk⟩ := Nat.le.dest h
    rw [← hk]
    symm
    apply closureSeq_asc
    apply mem_closureSeq

set_option maxHeartbeats 800000 in
/-- The linearizing function satisfies the functional equation, f( f(f(x)) - f(x) ) = x - f(x). -/
theorem closureLinear_funeq (f₀ : PartialSolution) :
    let f := closureLinear f₀;
    ∀ x, f (f (f x) - f x) = x - f x := by
  sorry
  -- dsimp
  -- intro x
  -- have hx₁ : x ∈ (f₀.closureSeq (Encodable.encode x + 1)).Dom :=
  --   f₀.mem_closureSeq x
  -- have hx₂ : (f₀.closureSeq (Encodable.encode x + 1)).f x ∈ (f₀.closureSeq (Encodable.encode x + 1)).Dom :=
  --   f₀.mem_f_closureSeq x
  -- rw [f₀.closureLinear_eq_closureSeq (Encodable.encode x + 1) x hx₁]
  -- rw [f₀.closureLinear_eq_closureSeq (Encodable.encode x + 1) _ hx₂]
  -- rw [f₀.closureLinear_eq_closureSeq (Encodable.encode x + 1)]
  -- · apply PartialSolution.Valid _ hx₁ hx₂
  -- · apply PartialSolution.Closed_sub _ hx₁ hx₂

/-- The linearizing function agrees with the initial PartialSolution on its support. -/
theorem closureLinear_extends (f₀ : PartialSolution) :
    ∀ x, (h : x ∈ f₀.Dom) → closureLinear f₀ x = f₀.f x :=
  fun x ↦ closureSeq_extends _ _ x

/-- Define the magma from the linearizing function. -/
def closure (f : PartialSolution) : A → A → A :=
  fun a b ↦ a + (closureLinear f) (b - a)

/-- The resulting magma obeys the Obelix rule. -/
theorem closure_prop (f : PartialSolution) : ∀ x y,
    x = closure f (closure f y x) (closure f y (closure f y x)) :=
  fun x y ↦ by simp [closure, closureLinear_funeq f (x - y)]

private abbrev x₁ : A := fun₀ | 0 => 1
private abbrev x₂ : A := fun₀ | 1 => 1
private abbrev x₃ : A := fun₀ | 2 => 1
private abbrev x₄ : A := fun₀ | 3 => 1

/-- An initial solution, given by the empty partial function. -/
def initial : PartialSolution where
  Dom := {0, x₁, x₂ - x₁, x₁ + x₃}
  f := (fun₀ | x₁ => x₂ | x₂ - x₁ => x₃ | x₁ + x₃ => x₄ : DFinsupp _)
  Inj := by
    intro x hx y hy
    simp only [Finset.coe_insert, Finset.coe_singleton] at hx hy
    rcases hx with (rfl|rfl|rfl|rfl)
    <;> rcases hy with (rfl|rfl|rfl|rfl)
    <;> decide
  Dom0 := by simp
  Id := by repeat rw [DFinsupp.coe_update, Function.update_noteq] <;> decide
  Closed_sub := by decide
  Valid := by decide
  SubInj := by
    intro a b
    simp only [Finset.mem_insert, Finset.mem_singleton]
    rintro (rfl|rfl|rfl|rfl)
    <;> rintro (rfl|rfl|rfl|rfl)
    <;> decide
  ExtendDom := by decide
  ExtendImg := by
    intro
    simp only [Finset.mem_insert, Finset.mem_singleton, ← Finset.coe_image]
    rintro (rfl|rfl|rfl|rfl) <;> decide

open Classical in
-- @[equational_result]
theorem Equation1491_facts : ∃ (G : Type) (_ : Magma G), Facts G [1491] [65] := by
  use A, ⟨initial.closure⟩
  simp only [Equation1491, closure_prop, implies_true, not_forall, true_and]
  constructor
  · exact closure_prop initial
  · use 0, -x₁
    nth_rewrite 3 [closure]
    rw [sub_neg_eq_add, zero_add, initial.closureLinear_extends x₁ (by decide)]
    rw [show initial.f x₁ = x₂ by decide]
    nth_rewrite 2 [closure]
    rw [sub_zero, zero_add, add_comm, initial.closureLinear_extends (x₂+(-x₁)) (by decide)]
    rw [show initial.f (x₂+(-x₁)) = x₃ by decide]
    rw [closure]
    rw [sub_neg_eq_add, add_comm x₃, initial.closureLinear_extends (x₁+x₃) (by decide)]
    rw [show initial.f (x₁+x₃) = x₄ by decide]
    trivial
