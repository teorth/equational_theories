import Mathlib.Algebra.Order.Ring.Nat
import Mathlib.Data.DFinsupp.Notation
import Mathlib.Data.ZMod.Defs
import Mathlib.Logic.Denumerable
import Mathlib.Tactic

import equational_theories.FactsSyntax
import equational_theories.EquationalResult
import equational_theories.Equations.Basic

-- The ``Obelix law''
-- equation 1491 := x = (y ◇ x) ◇ (y ◇ (y ◇ x))

namespace Obelix

--The particular group that we'll work on: ℕ-indexed functions to ℤ with finite support.
--To ensure that this is computable (so that we can get the first few elements and verify
--that our non-Astericity), we use DFinsupp, the computable (and dependent) friend of Finsupp.
--The ℕ lets us easily get "fresh" generators to keep extending the function. Finite support means
--that the group is still countable, so we can denumerate every element and eventually add it
--to the domain. We could easily use ℚ or Fin p instead of ℤ if we wanted.
--Significant amounts of the construction -- even defining the invariants of the partial function --
--depend on this, so we use it explicitly instead of making PartialSolution depend on a group G.
abbrev A : Type := Π₀ _ : ℕ, ℤ

instance A_group : AddCommGroup A := inferInstance

@[ext]
structure PartialSolution where
  --A partial solution is a function f : A → A satisfying certain invariants, with finite domain Dom.
  Dom : Finset A
  f : A → A
  --f is injective on its domain.
  Inj : Dom.toSet.InjOn f
  --f maps the identity to itself
  Dom0 : 0 ∈ Dom
  Id : f 0 = 0
  --If x and f(x) are in the domain, so is f (f x) - f(x).
  Closed_sub : ∀ {a}, a ∈ Dom → f a ∈ Dom → f (f a) - f a ∈ Dom
  --For all x where it's defined, f( f(f(x)) - f(x) ) = x - f(x).
  Valid : ∀ {a}, a ∈ Dom → f a ∈ Dom → f (f (f a) - f a) = a - f a
  --If a and b are in the domain and f(a)-a = f(b)-b, then a=b.
  --Could also be stated as "[fun x ↦ f(x)-x] is injective where defined", hence the name here.
  SubInj : ∀ {a b}, a ∈ Dom → b ∈ Dom → f a - a = f b - b → a = b
  --The extendability criteria: if b is in the image of f as f(a) but not the domain, then
  -- (1) a-b must not be in the domain, and (2) a-b must not be in the range.
  ExtendDom : ∀ {a}, a ∈ Dom → f a ∉ Dom → a - f a ∉ Dom
  ExtendImg : ∀ {a}, a ∈ Dom → f a ∉ Dom → a - f a ∉ f '' Dom

namespace PartialSolution

/-- The image of the partial solution -/
def Im (f : PartialSolution) := f.Dom.image f.f

/-- f.ExtendImg, stated in terms of f.Im -/
theorem ExtendImg' (f : PartialSolution) : ∀ {a}, a ∈ f.Dom → f.f a ∉ f.Dom → a - f.f a ∉ f.Im := by
  intro a h₁ h₂
  convert f.ExtendImg h₁ h₂
  funext x
  simp only [Im, Finset.mem_image, Set.mem_image, Finset.mem_coe]

/-- Get a fresh generator that's not generated by the values in the domain so far, the images
 so far, and a new value x. (If x isn't needed, we can just provide 0.) -/
@[irreducible]
def freshGenerator (f : PartialSolution) (x : A) : A :=
  --Get a number newI that is not in the *support* of any element of f
  let newI := 1 + (f.Dom.image (fun (x : A) ↦ x.support.max.unbot' 0)).max.unbot' 0;
  --Get a number newJ that is not in the *image* of any element of f. Then turn ℤ to ℕ
  let newJ' := 1 + (f.Dom.image (fun (x : A) ↦ (x.support.image x).max.unbot' 0)).max.unbot' 0;
  let newJ := newJ'.toNat;
  --Get a number newK that is not in the support of x
  let newK := 1 + (x.support.max.unbot' 0)
  --Produce the generator that maps max(newI,newJ,newK) to "1"
  fun₀ | (newI.max newJ).max newK => 1

theorem freshGenerator_not_subugroup (f : PartialSolution) (x : A) :
    f.freshGenerator x ∉ AddSubgroup.closure (f.Dom ∪ f.Im ∪ {x}) := by
  sorry

theorem freshGenerator_not_dom (f : PartialSolution) : f.freshGenerator 0 ∉ f.Dom := by
  have := AddSubgroup.not_mem_of_not_mem_closure (f.freshGenerator_not_subugroup 0)
  rw [Set.union_assoc] at this
  contrapose! this
  exact Set.mem_union_left _ this

theorem freshGenerator_not_img (f : PartialSolution) : f.freshGenerator 0 ∉ f.f '' f.Dom := by
  sorry

theorem freshGenerator_not_eq_dom (f : PartialSolution) {x : A} (h : x ∈ f.Dom) : x + x ≠ f.freshGenerator 0 := by
  sorry

theorem freshGenerator_not_eq_img (f : PartialSolution) {x : A} (h : x ∈ f.f '' f.Dom) : x + x ≠ f.freshGenerator 0 := by
  sorry

/-- Extend a partial solution at an element x *in* its domain, so that x obeys the functional equation. -/
def extend (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) : PartialSolution :=
  if hb : f.f x ∈ f.Dom then f else
    let b := f.f x;
    let c := f.freshGenerator 0;
    have hb :  b ∉ f.Dom := hb
    have hb₀ : b ≠ 0 := fun h ↦ hb (h ▸ f.Dom0 : b ∈ f.Dom)
    have hc₀ : c ≠ 0 := fun h ↦ (f.freshGenerator_not_dom) (h ▸ f.Dom0 : c ∈ f.Dom)
    have hbc : b ≠ c := by
      have := by simpa using f.freshGenerator_not_img
      exact this x hx
    have h2bc : b + b ≠ c := by
      apply freshGenerator_not_eq_img
      use x, hx
    have hcbb : c - b ≠ b := by
      intro h
      nth_rewrite 1 [←h] at h2bc
      simp at h2bc
    have hcbcb : c ≠ b - (c - b) := by
      sorry
    have hzcb : ∀ z ∈ f.Dom, z ≠ c - b := by
      sorry
  {
    Dom := insert b <| insert (c - b) f.Dom
    f := fun x ↦
      if x = b then c
      else if x = c - b then b - x
      else f.f x
    Inj := by
      intro x hx y hy
      simp at hx hy
      rcases hx with (hx|hx|hx) <;>
      rcases hy with (hy|hy|hy)
      all_goals try simp only [hx, hy, ↓reduceIte, imp_self, hcbb]
      all_goals try (have hyb : y ≠ b := fun h ↦ hb (h ▸ hy); simp [hyb])
      all_goals try (have hxb : x ≠ b := fun h ↦ hb (h ▸ hx); simp [hxb])
      all_goals try (have hycb := hzcb y hy; simp [hycb])
      all_goals try (have hxcb := hzcb x hx; simp [hxcb])
      all_goals try clear x hx
      all_goals try clear y hy
      · exact fun h ↦ (hcbcb h).elim
      · sorry
      · exact hcbcb.symm
      · sorry
      · intro h2
        apply f.freshGenerator_not_img
        use x, hx
      · sorry
      · exact f.Inj hx hy
    Dom0 := by simp [f.Dom0]
    Id := by simpa [hb₀.symm, Ne.symm (sub_ne_zero_of_ne hbc.symm)] using f.Id
    Closed_sub := by sorry
    Valid := by sorry
    SubInj := by sorry
    ExtendDom := by
      intro y hy
      simp at hy
      rcases hy with (hy|hy|hy)
      · simp [hy, hc₀]
        intro h1 h2 h3
        constructor
        · sorry
        · sorry
      · simp [hy, hc₀, hcbb]
        intro h1 h2 h3
        constructor
        · sorry
        · constructor
          · sorry
          · sorry
      · have hyb : y ≠ b := fun h ↦ hb (h ▸ hy)
        simp [hyb, hzcb y hy]
        intro h1 h2 h3
        constructor
        · sorry
        · constructor
          · sorry
          · sorry
    ExtendImg := by sorry
  }

/-- Extend preserves the function on its support -/
theorem extend_mono (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    ∀ y ∈ f.Dom, y ∈ (f.extend hx).Dom ∧ f.f y = (f.extend hx).f y := by
  intro y hy
  by_cases hf : f.f x ∈ f.Dom
  · simp [extend, hf, hy]
  · simp [extend, hf]
    by_cases hyf : y = f.f x
    · exact (hf (hyf ▸ hy)).elim
    · have : f.freshGenerator 0 ≠ y + f.f x := by
        sorry --by subgroup
      have : y ≠ f.freshGenerator 0 - f.f x := this.symm ∘ add_eq_of_eq_sub
      simp [hyf, hy, this]

theorem extend_mono_dom (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    ∀ y ∈ f.Dom, y ∈ (f.extend hx).Dom :=
  fun y hy ↦ ((f.extend_mono hx) y hy).1

theorem extend_mono_f (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    ∀ y ∈ f.Dom, f.f y = (f.extend hx).f y :=
  fun y hy ↦ ((f.extend_mono hx) y hy).2

/-- Extend makes sure that f x is in the domain -/
theorem extend_dom (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    (f.extend hx).f x ∈ (f.extend hx).Dom := by
  by_cases hf : f.f x ∈ f.Dom
  · simp [extend, hf]
  · simp [extend, hf]
    by_cases hxf : x = f.f x
    · exact (hf (hxf ▸ hx)).elim
    · have : f.freshGenerator 0 ≠ x + f.f x := by
        sorry --by subgroup
      have : x ≠ f.freshGenerator 0 - f.f x := this.symm ∘ add_eq_of_eq_sub
      simp [hxf, this]

/-- Extend makes sure that x obeys the functional equation -/
theorem extend_valid (f : PartialSolution) {x : A} (hx : x ∈ f.Dom) :
    let f' := (f.extend hx).f; f' (f' (f' x) - f' x) = x - f' x :=
  (f.extend hx).Valid (f.extend_mono_dom hx x hx) (f.extend_dom hx)

/-- Extend a partial solution with an element *not* in its domain. -/
def add (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im) : PartialSolution :=
  let b := f.freshGenerator x;
  have hx₀ : x ≠ 0 := fun h ↦ hx (h ▸ f.Dom0 : x ∈ f.Dom)
  have hbx : b ≠ x := by sorry
  have hbdom : b ∉ f.Dom := by sorry
  {
    Dom := insert x f.Dom
    f := fun y ↦ if x = y then b else f.f y
    Inj := by sorry
    Dom0 := by simp [f.Dom0]
    Id := by simp [hx₀, f.Id]
    Closed_sub := by
      intro y hy
      simp at hy
      rcases hy with (hy|hy)
      · simp [hy, hbx, hbdom]
      · have hxy : x ≠ y := fun h ↦ hx (h ▸ hy : x ∈ f.Dom)
        have hxy2 : f.f y ≠ x := fun h ↦ hxi (by simp [Im]; use y)
        simp [hxy, hxy2, hxy2.symm]
        exact fun h ↦ Or.inr (f.Closed_sub hy h)
    Valid := by sorry
    SubInj := by sorry
    ExtendDom := by sorry
    ExtendImg := by sorry
  }

/-- Add preserves the function on its domain -/
theorem add_mono (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im) :
    ∀ y ∈ f.Dom, y ∈ (f.add hx hxi).Dom ∧ f.f y = (f.add hx hxi).f y := by
  intro y hy
  have hxy : x ≠ y := fun h ↦ hx (h ▸ hy)
  simp [add, hy, hxy]

theorem add_mono_dom (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im) :
    ∀ y ∈ f.Dom, y ∈ (f.add hx hxi).Dom :=
  fun y hy ↦ (f.add_mono hx hxi y hy).1

theorem add_mono_f (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im) :
    ∀ y ∈ f.Dom, f.f y = (f.add hx hxi).f y :=
  fun y hy ↦ (f.add_mono hx hxi y hy).2

/-- The added partial solution has the new element in the domain. -/
theorem add_dom (f : PartialSolution) {x : A} (hx : x ∉ f.Dom) (hxi : x ∉ f.Im) :
    x ∈ (f.add hx hxi).Dom := by
  simp [add]

/-- Given f, (possibly) extend it to ensure that x is in the domain, image, and obeys the functional
  equation. This is done by possibly using `add` to include x, and then `extend`. -/
def close (f : PartialSolution) (x : A) : PartialSolution :=
  if hx : x ∈ f.Dom then
    --If x is in the domain, just make sure that it obeys the functional equation with `extend`.
    f.extend hx
  else if hxi : x ∈ f.Im then
    --If x is in the image but not the domain, find the unique y such that f(y) = x
    let y : A := Finset.choose (f.f · = x) f.Dom (by
      obtain ⟨y,hy₁,hy₂⟩ := Finset.mem_image.mp hxi;
      use y
      simp [hy₁, hy₂]
      exact fun _ hz ↦ hy₂ ▸ (f.Inj hz hy₁)
    )
    have hy : y ∈ f.Dom := Finset.choose_mem _ _ _
    have hfy₂ : (f.extend hy).f y = x := (f.extend_mono_f _ y hy).symm.trans
      (Finset.choose_spec (f.f · = x) _ _).2
    --And then `extend y` (so that x is in the domain), and finally `extend x`
    (f.extend hy).extend (hfy₂ ▸ f.extend_dom hy)
  else
    --Otherwise x is in neither the domain nor the image and we use `add`, `extend`.
    (f.add hx hxi).extend (f.add_dom hx hxi)

/-- The closed partial solution has the new element `x` in the domain. -/
theorem close_dom (f : PartialSolution) {x : A} :
    x ∈ (f.close x).Dom := by
  rw [close]
  split_ifs with h₁ h₂ <;> apply extend_mono_dom
  · exact h₁
  · exact close.proof_4 f x h₂ _ (close.proof_3 f x h₂ _)
  · apply add_dom

/-- The closed partial solution has `f x` in the domain. -/
theorem close_f_dom (f : PartialSolution) {x : A} :
    (f.close x).f x ∈ (f.close x).Dom := by
  rw [close]
  split_ifs with h₁ h₂ <;> apply extend_dom

instance instADenumerable : Denumerable A :=
  Denumerable.ofEncodableOfInfinite A

/-- Repeatedly extend f by the least element not in its domain, and the bifurcation tree that element
  generates. -/
def closureSeq (f : PartialSolution) : ℕ → PartialSolution
| 0 => f
| n+1 => (closureSeq f n).close (Denumerable.ofNat A n)

attribute [-instance] instEncodableDFinsuppOfDecidableNeOfNat in
theorem mem_closureSeq (f : PartialSolution) (x : A) :
    x ∈ (f.closureSeq (Encodable.encode x + 1)).Dom := by
  rw [closureSeq.eq_def]
  simp only [Denumerable.ofNat_encode _]
  apply close_dom

attribute [-instance] instEncodableDFinsuppOfDecidableNeOfNat in
/-- Make the linearizing function f from the closure. -/
def closureLinear (f : PartialSolution) : A → A :=
  fun a ↦ (f.closureSeq (Encodable.encode a)).f a

/-- The linearizing function satisfies the functional equation, f( f(f(x)) - f(x) ) = x - f(x). -/
theorem closureLinear_funeq (f₀ : PartialSolution) :
    let f := closureLinear f₀;
    ∀ x, f (f (f x) - f x) = x - f x := by
  sorry

/-- The linearizing function agrees with the initial PartialSolution on its support. -/
theorem closureLinear_extends (f₀ : PartialSolution) :
    ∀ x, (h : x ∈ f₀.Dom) → closureLinear f₀ x = f₀.f x := by
  sorry

/-- Define the magma from the linearizing function. -/
def closure (f : PartialSolution) : A → A → A :=
  fun a b ↦ a + (closureLinear f) (b - a)

/-- The resulting magma obeys the Obelix rule. -/
theorem closure_prop (f : PartialSolution) : ∀ x y,
    x = closure f (closure f y x) (closure f y (closure f y x)) :=
  fun x y ↦ by simp [closure, closureLinear_funeq f (x - y)]

private abbrev x₁ : A := fun₀ | 0 => 1
private abbrev x₂ : A := fun₀ | 1 => 1
private abbrev x₃ : A := fun₀ | 2 => 1
private abbrev x₄ : A := fun₀ | 3 => 1

/-- An initial solution, given by the empty partial function. -/
def initial : PartialSolution where
  Dom := {0, x₁, x₂ - x₁, x₁ + x₃}
  f := (fun₀ | x₁ => x₂ | x₂ - x₁ => x₃ | x₁ + x₃ => x₄ : DFinsupp _)
  Inj := by
    intro x hx y hy
    simp only [Finset.coe_insert, Finset.coe_singleton] at hx hy
    rcases hx with (rfl|rfl|rfl|rfl)
    <;> rcases hy with (rfl|rfl|rfl|rfl)
    <;> decide
  Dom0 := by simp
  Id := by repeat rw [DFinsupp.coe_update, Function.update_noteq] <;> decide
  Closed_sub := by decide
  Valid := by decide
  SubInj := by
    intro a b
    simp only [Finset.mem_insert, Finset.mem_singleton]
    rintro (rfl|rfl|rfl|rfl)
    <;> rintro (rfl|rfl|rfl|rfl)
    <;> decide
  ExtendDom := by decide
  ExtendImg := by
    intro
    simp only [Finset.mem_insert, Finset.mem_singleton, ← Finset.coe_image]
    rintro (rfl|rfl|rfl|rfl) <;> decide

open Classical in
-- @[equational_result]
theorem Equation1491_facts : ∃ (G : Type) (_ : Magma G), Facts G [1491] [65] := by
  use A, ⟨initial.closure⟩
  simp only [Equation1491, closure_prop, implies_true, not_forall, true_and]
  constructor
  · exact closure_prop initial
  · use 0, -x₁
    nth_rewrite 3 [closure]
    rw [sub_neg_eq_add, zero_add, initial.closureLinear_extends x₁ (by decide)]
    rw [show initial.f x₁ = x₂ by decide]
    nth_rewrite 2 [closure]
    rw [sub_zero, zero_add, add_comm, initial.closureLinear_extends (x₂+(-x₁)) (by decide)]
    rw [show initial.f (x₂+(-x₁)) = x₃ by decide]
    rw [closure]
    rw [sub_neg_eq_add, add_comm x₃, initial.closureLinear_extends (x₁+x₃) (by decide)]
    rw [show initial.f (x₁+x₃) = x₄ by decide]
    trivial
